---
title: 'Drivers of variation in the community response to temperature change across realms'
subtitle: '(using mixed effects models)'
output: 
    github_document: default
    #html_document: default
    html_notebook: default
---

Collaborators: Shane Blowes, Jon Chase, Helmut Hillebrand, Michael Burrows, Amanda Bates, Uli Brose, Benoit Gauzens, Laura Antao, Ruben Remelgado, Carsten Meyer, Myriam Hirt, maybe others
Assistance: Katherine Lew, Josef Hauser

# Introduction
- Climate change is driving a widespread reorganization of ecological communities around the world (Parmsesan & Yohe 2003, Poloczanska et al. 2013),
- but the impacts of climate change vary substantially from one location to another and among taxa (Molinos et al. 2016 NCC, Antao et al. 2020 NEE).
- Community reorganization is substantially more common than an aggregate loss or gain of species (Dornelas et al. 2014 Science, Blowes et al. 2019 Science, Hillebrand et al. 2017 J Appl Ecol)
- There are many hypotheses for why some communities are more sensitive to warming than others, including differences in
  - metabolic rates (Dillon et al. 2010 Nature), 
  - thermal physiology (Deutsch et al. 2008 PNAS, Pinsky et al. 2019 Nature), 
  - microclimate availability (Burrows et al. 2019 NCC, Suggitt et al. 2018 NCC),
  - species mobility (Poloczanska et al. 2013 NCC, Burrows et al. 2011 Science, Sunday et al. 2012 NCC)
  - or generation time (Beaugrand et al. 2009 DSR II, Poloczanska et al. 2013 NCC),
  - consumers vs. producers (Petchey et al. 1999 Nature)
  - community composition (Stuart-Smith et al. 2015 Nature, Beaugrand et a. 2015 NCC, Trisos et al. 2020 Nature), 
  - ecosystem productivity (Thomas et al. 2017 GCB, Brett 1971 Am Zoo),
  - exposure to human impacts (White & Kerr 2006 Ecography)
  - and among realms (Antao et al. 2020 NEE).
- Scaling up from organismal effects to whole ecological communities is complex, and yet these scales are critical for ecosystem functioning and human well-being. 
- There is a need for a comprehensive test to understand where warming is driving and is likely to drive the most dramatic community turnover

# Methods
- BioTime dataset, gridded to 96 km2 hexagons, summarized as temporal turnover (Blowes)
  - Temporal slope of Jaccard turnover compared to the first year (NOT including the first year compared to itself)
  - Same for Jaccard total
  - and Morisita-Horn turnover
- Explanatory variables considered for differences in rate of turnover:
  - Temperature trend over the time-frame of each time-series (CRU TS 4.03 on land and in freshwater, ERSST v5 in the ocean)
  - Seasonality as a metric of thermal sensitivity (Deutsch et al. 2008 PNAS). Standard deviation of monthly temperatures.
  - Microclimates calculated from WorldClim and BioOracle (Laura Antao)
  - Body mass, collated from databases and literature searches
  - Metabolic temperature, from average temperature if ectotherms (Dillon et al. 2010 Nature, Antao et al. 2020 Nat E&E)
  - Mobility calculated from body mass and taxonomic group classifications of mobility mode (fly, run, swim, crawl, sessile). Fly/run/swim followed the allometric relationship in Hirt et al. 2017 Nat E&E. Crawl set at 0.1 km/hr, sessile set to 0 km/hr. Then calculated averaged within each assemblage.
  - Generation time calculated from body mass and endotherm vs. ectotherm classifications, following McCoy & Gillooly 2008 ELE. Averaged across species within each assemblage. 
  - Consumer vs. producer classification by species
  - Endotherm vs. ectotherm classification by species
  - Species richness, calculated as the number of species in the assemblage
  - Net primary productivity (NPP) from the merged land/ocean product produced by the [Ocean Productivity](http://www.science.oregonstate.edu/ocean.productivity/) group at Oregon State using methods from Zhao et al. 2005 and Behrenfeld & Falkowski 1997. 
  - Human impact calculated from Bowler et al. 2020 (also try data from Venter et al. 2016 and Halpern et al. 2008)
  - Thermal bias calculated from Species Temperature Indices (Mike Burrows)
  - Vegetation cover index, calculated from %tree cover and %non-tree veg cover (latter counted as 1/2), from vegetation continuous fields (Ruben Remelgado)
- Differences in temporal turnover (response variable) modeled with a linear mixed effects model (nlme package, lme() function). See below for details.

```{r setup}
library(data.table) # for handling large datasets
library(ggplot2) # for some plotting
library(nlme) # for ME models
library(maps) # for map
library(gridExtra) # to combine ggplots together
library(grid) # to combine ggplots together
library(RColorBrewer)
library(MASS) # for stepAIC
library(piecewiseSEM) # for rsquared() for nlme models

options(width=500) # turn off most text wrapping

# tell RStudio to use project root directory as the root for this notebook. Needed since we are storing code in a separate directory.
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) 
```

```{r load data}
# Turnover and covariates assembled by turnover_vs_temperature_prep.Rmd
trends <- fread('output/turnover_w_covariates.csv.gz')

# set realm order
trends[, REALM := factor(REALM, levels = c('Freshwater', 'Marine', 'Terrestrial'), ordered = FALSE)]

# set up sign of temperature change
trends[, tsign := factor(sign(temptrend))]

# realm that combined Terrestrial and Freshwater, for interacting with human impact
trends[, REALM2 := REALM]
levels(trends$REALM2) = list(TerrFresh = "Freshwater", TerrFresh = "Terrestrial", Marine = "Marine")

# group Marine invertebrates/plants in with All
trends[, taxa_mod2 := taxa_mod]
trends[taxa_mod == 'Marine invertebrates/plants', taxa_mod2 := 'All']

# calculate duration
trends[, duration := maxyrBT - minyrBT + 1]

# trim to data with >= 3 yrs
trends <- trends[nyrBT >= 3, ]
```


### Log-transform some variables, then center and scale. 
``` {r center and scale}
trends[, tempave.sc := scale(tempave)]
trends[, tempave_metab.sc := scale(tempave_metab)]
trends[, seas.sc := scale(seas)]
trends[, microclim.sc := scale(log(microclim))]
trends[, temptrend.sc := scale(temptrend, center = FALSE)] # do not center
trends[, temptrend_abs.sc := scale(abs(temptrend), center = FALSE)] # do not center, so that 0 is still 0 temperature change
trends[, mass.sc := scale(log(mass_mean_weight))]
trends[, speed.sc := scale(log(speed_mean_weight+1))]
trends[, lifespan.sc := scale(log(lifespan_mean_weight))]
trends[, consumerfrac.sc := scale(consfrac)]
trends[, endothermfrac.sc := scale(endofrac)]
trends[, nspp.sc := scale(log(Nspp))]
trends[, thermal_bias.sc := scale(thermal_bias)]
trends[, npp.sc := scale(log(npp))]
trends[, veg.sc := scale(log(veg+1))]
trends[, duration.sc := scale(log(duration))]
trends[, human_bowler.sc := scale(log(human_bowler+1)), by = REALM2] # separate scaling by realm
trends[REALM2 == 'TerrFresh', human_footprint.sc := scale(log(human_venter+1))]
trends[REALM2 == 'Marine', human_footprint.sc := scale(log(human_halpern))]
```

### Examine how many data points are available
Just turnover
```{r sample size all}
cat('Overall # time-series: ', nrow(trends), '\n')
cat('# studies: ', trends[, length(unique(STUDY_ID))], '\n')
cat('Data points: ', trends[, sum(nyrBT)], '\n')
trends[, table(REALM)]
trends[, table(taxa_mod)]
trends[, table(taxa_mod, REALM)]
```

With all covariates (Bowler for human)
```{r sample size for Jaccard turnover}
# the cases we can compare
apply(trends[, .(Jtutrendrem0, REALM, tempave.sc, tempave_metab.sc, seas.sc, microclim.sc, temptrend.sc, mass.sc, speed.sc, lifespan.sc, consumerfrac.sc, endothermfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, veg.sc, human_bowler.sc)], MARGIN = 2, FUN = function(x) sum(!is.na(x)))
i <- trends[, complete.cases(Jtutrendrem0, tempave.sc, tempave_metab.sc, seas.sc, microclim.sc, temptrend.sc, mass.sc, speed.sc, lifespan.sc, consumerfrac.sc, endothermfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, veg.sc, human_bowler.sc)]
cat('Overall # time-series: ', sum(i), '\n')
cat('# studies: ', trends[i, length(unique(STUDY_ID))], '\n')
cat('Data points: ', trends[i, sum(nyrBT)], '\n')
trends[i, table(REALM)]
trends[i, table(taxa_mod)]
trends[i, table(taxa_mod, REALM)]
```

### Choose the variance structure for mixed effects models
Try combinations of

- variance scaled to a power of the number of years in the community time-series
- variance scaled to a power of the abs temperature trend
- random intercept for taxa_mod
- random intercept for STUDY_ID
- random slope (abs temperature trend) for taxa_mod
- random slope (abs temperature trend) for STUDY_ID
- random intercept for rarefyID (for overdispersion)

And choose the one with lowest AIC (not run: takes a long time)
```{r choose variance structure for Jacard turnover, eval = FALSE}
# fit models for variance structure
fixed <- formula(Jtutrendrem0 ~ temptrend_abs.sc*REALM +
                     temptrend_abs.sc*tsign + 
                     temptrend_abs.sc*tempave_metab.sc + 
                     temptrend_abs.sc*seas.sc + 
                     temptrend_abs.sc*microclim.sc + 
                     temptrend_abs.sc*mass.sc + 
                     temptrend_abs.sc*speed.sc + 
                     temptrend_abs.sc*consumerfrac.sc +
                     temptrend_abs.sc*nspp.sc +
                     temptrend_abs.sc*thermal_bias.sc:tsign +
                     temptrend_abs.sc*npp.sc +
                     temptrend_abs.sc*veg.sc +
                     temptrend_abs.sc*duration.sc +
                     temptrend_abs.sc*human_bowler.sc:REALM2)
i <- trends[, complete.cases(Jtutrendrem0, temptrend_abs.sc, REALM, tsign, tempave_metab.sc, seas.sc, 
                             microclim.sc, mass.sc, speed.sc, consumerfrac.sc, nspp.sc,
                             thermal_bias.sc, npp.sc, veg.sc, human_bowler.sc)]
mods <- vector('list', 0)
mods[[1]] <- gls(fixed, data = trends[i,])
mods[[2]] <- gls(fixed, data = trends[i,], weights = varPower(-0.5, ~nyrBT))
mods[[3]] <- gls(fixed, data = trends[i,], weights = varPower(0.5, ~temptrend_abs.sc))

mods[[4]] <- lme(fixed, data = trends[i,], random = ~1|taxa_mod2, control = lmeControl(opt = "optim"))
mods[[5]] <- lme(fixed, data = trends[i,], random = ~1|STUDY_ID, control = lmeControl(opt = "optim"))
mods[[6]] <- lme(fixed, data = trends[i,], random = ~1|taxa_mod2/STUDY_ID, control = lmeControl(opt = "optim"))
mods[[7]] <- lme(fixed, data = trends[i,], random = ~1|STUDY_ID/rarefyID, control = lmeControl(opt = "optim"))
mods[[8]] <- lme(fixed, data = trends[i,], random = ~1|taxa_mod2/STUDY_ID/rarefyID, control = lmeControl(opt = "optim"))

mods[[9]] <- lme(fixed, data = trends[i,], random = ~temptrend_abs.sc | taxa_mod)
mods[[10]] <- lme(fixed, data = trends[i,], random = list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1)) # includes overdispersion. new formula so that random slope is only for study level (not enough data to extend to rarefyID).

mods[[11]] <- lme(fixed, data = trends[i,], random = list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1), weights = varPower(-0.5, ~nyrBT))
mods[[12]] <- lme(fixed, data = trends[i,], random = list(taxa_mod2 = ~ temptrend_abs.sc, STUDY_ID = ~ 1, rarefyID = ~1), weights = varPower(-0.5, ~nyrBT))

aics <- sapply(mods, AIC)
minaics <- aics - min(aics)
minaics
which.min(aics)
```
Chooses the random slopes (temptrend_abs) & intercepts for STUDY_ID, overdispersion, and variance scaled to number of years.
We haven't dealt with potential testing on the boundary issues here yet.

# Results
## Where do we have data?
```{r map}
world <- map_data('world')
ggplot(world, aes(x = long, y = lat, group = group)) +
    geom_polygon(fill = 'lightgray', color = 'white') +
    geom_point(data = trends, aes(rarefyID_x, rarefyID_y, group = REALM, color = REALM), size = 0.5, alpha = 0.4)  +
    scale_color_brewer(palette="Set1", name = 'Realm') +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.key=element_blank(),
        axis.text=element_text(size=16),
        axis.title=element_text(size=20)) +
  labs(x = 'Longitude (°)', y = 'Latitude (°)')
```

Mostly northern hemisphere, but spread all over. Not so much in Africa or much of Asia.




##Average rates of turnover (without year 1)
```{r rates of turnover rem0}
trends[abs(temptrend) >= 0.5, temptrendtext1 := 'Changing']
trends[abs(temptrend) <= 0.05, temptrendtext1 := 'Stable']
trends[temptrend <= -0.5, temptrendtext2 := 'Cooling']
trends[abs(temptrend) <= 0.05, temptrendtext2 := 'Stable']
trends[temptrend >= 0.5, temptrendtext2 := 'Warming']

trendsum1 <- trends[!is.na(temptrendtext1), 
                    .(type = 'Jtu', 
                      ave = mean(Jtutrendrem0, na.rm=TRUE), 
                      se = sd(Jtutrendrem0, na.rm=TRUE)/sqrt(.N),
                      n = sum(!is.na(Jtutrendrem0))),
                    by = temptrendtext1] # turnover per year for locations changing temperature
trendsum1 <- rbind(trendsum1, trends[!is.na(temptrendtext1), 
                    .(type = 'Jbeta', 
                      ave = mean(Jbetatrendrem0, na.rm=TRUE), 
                      se = sd(Jbetatrendrem0, na.rm=TRUE)/sqrt(.N),
                      n = sum(!is.na(Jbetatrendrem0))),
                    by = temptrendtext1])
trendsum1 <- rbind(trendsum1, trends[!is.na(temptrendtext1), 
                    .(type = 'Horn', 
                      ave = mean(Horntrendrem0, na.rm=TRUE), 
                      se = sd(Horntrendrem0, na.rm=TRUE)/sqrt(.N),
                      n = sum(!is.na(Horntrendrem0))),
                    by = temptrendtext1])

trendsum2 <- trends[!is.na(temptrendtext2), 
                    .(type = 'Jtu', 
                      ave = mean(Jtutrendrem0, na.rm=TRUE), 
                      se = sd(Jtutrendrem0, na.rm=TRUE)/sqrt(.N),
                      n = sum(!is.na(Jtutrendrem0))),
                    by = temptrendtext2] # turnover per year for locations changing temperature (inc. direction)
trendsum2 <- rbind(trendsum2, trends[!is.na(temptrendtext2), 
                    .(type = 'Jbeta', 
                      ave = mean(Jbetatrendrem0, na.rm=TRUE), 
                      se = sd(Jbetatrendrem0, na.rm=TRUE)/sqrt(.N),
                      n = sum(!is.na(Jbetatrendrem0))),
                    by = temptrendtext2])
trendsum2 <- rbind(trendsum2, trends[!is.na(temptrendtext2), 
                    .(type = 'Horn', 
                      ave = mean(Horntrendrem0, na.rm=TRUE), 
                      se = sd(Horntrendrem0, na.rm=TRUE)/sqrt(.N),
                      n = sum(!is.na(Horntrendrem0))),
                    by = temptrendtext2])



trendsum1
trendsum2
```

### Plots of turnover rates
```{r turnover vs. temperature violin plot}
p1 <- ggplot(trends[!is.na(temptrendtext1), ], aes(temptrendtext1, Horntrendrem0)) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), fill = 'grey') +
  labs(x = '', y = 'Turnover', tag = 'A', title = 'Rate of temperature change') +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.key=element_blank(),
        axis.text=element_text(size=8),
        axis.title=element_text(size=10)) +
  geom_abline(intercept = 0, slope = 0)

p2 <- ggplot(trends[!is.na(temptrendtext2), ], aes(temptrendtext2, Horntrendrem0)) +
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), fill = 'grey') +
  labs(x = '', y = 'Turnover', tag = 'A', title = 'Rate of temperature change') +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.key=element_blank(),
        axis.text=element_text(size=8),
        axis.title=element_text(size=10)) +
  geom_abline(intercept = 0, slope = 0)

p3 <- ggplot(trendsum1, aes(temptrendtext1, ave, group = type, color = type)) +
  geom_point(position = position_dodge(width = 0.25), size = 0.5) +
  geom_errorbar(aes(ymin=ave-se, ymax=ave+se), width=.1, position = position_dodge(width = 0.25)) +
  labs(x = '', y = 'Temporal turnover', title = 'Jaccard turnover') +
  geom_abline(intercept = 0, slope = 0, linetype = 'dashed') +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.key=element_blank(),
        axis.text=element_text(size=8),
        axis.title=element_text(size=10)) +
  coord_cartesian(ylim = c(0,0.04))

p4 <- ggplot(trendsum2, aes(temptrendtext2, ave, group = type, color = type)) +
  geom_point(position = position_dodge(width = 0.25), size = 0.5) +
  geom_errorbar(aes(ymin=ave-se, ymax=ave+se), width=.1, position = position_dodge(width = 0.25)) +
  labs(x = '', y = 'Temporal turnover', title = 'Jaccard turnover') +
  geom_abline(intercept = 0, slope = 0, linetype = 'dashed') +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.key=element_blank(),
        axis.text=element_text(size=8),
        axis.title=element_text(size=10))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

## Temperature-only model (Jtutrend, Jbetatrend, Horntrend)
```{r LME temperature only rem0}
i4 <- trends[, complete.cases(Jtutrendrem0, REALM, temptrend)]

randef <- list(STUDY_ID = ~ abs(temptrend), rarefyID = ~1)
varef <- varPower(-0.5, ~nyrBT)

if(file.exists('temp/modonlyTtrendrem0.rds')){
  modonlyTtrendrem0 <- readRDS('temp/modonlyTtrendrem0.rds')
} else {
  modonlyTtrendrem0 <- lme(Jtutrendrem0 ~ abs(temptrend)*REALM,
                   random = randef, weights = varef, data = trends[i4,], method = 'REML')
  saveRDS(modonlyTtrendrem0, file = 'temp/modonlyTtrendrem0.rds')
}

i5 <- trends[, complete.cases(Jbetatrendrem0, REALM, temptrend)]
if(file.exists('temp/modonlyTtrendJbetarem0.rds')){
  modonlyTtrendJbetarem0 <- readRDS('temp/modonlyTtrendJbetarem0.rds')
} else {
  modonlyTtrendJbetarem0 <- lme(Jbetatrendrem0 ~ abs(temptrend)*REALM,
                   random = randef, weights = varef, data = trends[i5,], method = 'REML', 
                   control=lmeControl(msMaxIter = 100, maxIter = 100))
  saveRDS(modonlyTtrendJbetarem0, file = 'temp/modonlyTtrendJbetarem0.rds')
}

i6 <- trends[, complete.cases(Horntrendrem0, REALM, temptrend)]
if(file.exists('temp/modonlyTtrendHornrem0.rds')){
  modonlyTtrendHornrem0 <- readRDS('temp/modonlyTtrendHornrem0.rds')
} else {
  modonlyTtrendHornrem0 <- lme(Horntrendrem0 ~ abs(temptrend)*REALM,
                   random = randef, weights = varef, data = trends[i6,], method = 'REML')
  saveRDS(modonlyTtrendHornrem0, file = 'temp/modonlyTtrendHornrem0.rds')
}

summary(modonlyTtrendrem0)
summary(modonlyTtrendJbetarem0)
summary(modonlyTtrendHornrem0)


```


### Plot the temp-only coefficients
```{r modonlyTtrendsimp coefs}
colors <- brewer.pal(3, 'Dark2')

# make table of coefficients
coefs1 <- as.data.frame(summary(modonlyTtrendrem0)$tTable)
coefs2 <- as.data.frame(summary(modonlyTtrendJbetarem0)$tTable)
coefs3 <- as.data.frame(summary(modonlyTtrendHornrem0)$tTable)
coefs1$mod <- 'Jtu'
coefs2$mod <- 'Jbeta'
coefs3$mod <- 'Horn'
rows1 <- which(grepl('temptrend', rownames(coefs1))) # extract temperature effect
cols <- c('Value', 'Std.Error', 'mod')
allcoefs <- rbind(coefs1[rows1, cols], coefs2[rows1, cols], coefs3[rows1, cols])
allcoefs$Value[grepl('REALMMarine', rownames(allcoefs))] <- 
  allcoefs$Value[grepl('REALMMarine', rownames(allcoefs))] + 
  allcoefs$Value[!grepl('REALM', rownames(allcoefs))] # add intercept to marine effects
allcoefs$Value[grepl('REALMTerrestrial', rownames(allcoefs))] <- 
  allcoefs$Value[grepl('REALMTerrestrial', rownames(allcoefs))] + 
  allcoefs$Value[!grepl('REALM', rownames(allcoefs))] # add intercept to terrestrial effects

allcoefs$lCI <- allcoefs$Value - allcoefs$Std.Error # lower confidence interval
allcoefs$uCI <- allcoefs$Value + allcoefs$Std.Error
allcoefs$y <- c(3, 2, 1) + rep(c(0, -0.1, -0.2), c(3, 3, 3)) # y-values
allcoefs$col <- c(rep(colors[1], 3), rep(colors[2], 3), rep(colors[3], 3))
allcoefs$realm <- rep(c('Freshwater', 'Marine', 'Terrestrial'), 3)

par(las = 1, mai = c(0.8, 2, 0.1, 0.1))
plot(0,0, col = 'white', xlim=c(-0.1, 0.85), ylim = c(0.5,3), 
     yaxt='n', xlab = 'Turnover per |°C/yr|', ylab ='')
axis(2, at = 3:1, labels = c('Freshwater', 'Marine', 'Terrestrial'), cex.axis = 0.7)
abline(v = 0, col = 'grey')
for(i in 1:nrow(allcoefs)){
  with(allcoefs[i, ], points(Value, y, pch = 16, col = col))
  with(allcoefs[i, ], lines(x = c(lCI, uCI), y = c(y, y), col = col))
}
legend('bottomright', col = colors, lwd = 1, pch = 16, 
       legend = c('Jaccard turnover', 'Jaccard total', 'Horn-Morisita',
                  'Jaccard turnover rem0', 'Jaccard total rem0', 'Horn-Morisita rem0'))

```

## Full models
Try static covariates plus interactions of abs temperature trend with each covariate:

- realm
- speed
- mass
- average metabolic temperature
- consumer fraction
- environmental temperature
- seasonality
- microclimates
- thermal bias
- NPP
- vegetation
- duration
- human footprint

Except for thermal bias: interact with temperature trend (not abs)

### Fit full models
#### Bowler vs Venter/Halpern human impact
Bowler has lower AIC.
```{r LME Jacard turnover temperature full rem0}
# using Bowler for human impact
i1 <- trends[, complete.cases(Jtutrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc, human_footprint.sc)]

randef <- list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1)
varef <- varPower(-0.5, ~nyrBT)

if(file.exists('temp/modTfullbowlerrem0.rds')){
  modTfullbowlerrem0 <- readRDS('temp/modTfullbowlerrem0.rds')
} else {

modTfullbowlerrem0 <- lme(Jtutrendrem0 ~ temptrend_abs.sc*REALM +
                     temptrend_abs.sc*tsign + 
                     temptrend_abs.sc*tempave_metab.sc + 
                     temptrend_abs.sc*seas.sc + 
                     temptrend_abs.sc*microclim.sc + 
                     temptrend_abs.sc*mass.sc + 
                     temptrend_abs.sc*speed.sc + 
                     temptrend_abs.sc*consumerfrac.sc +
                     temptrend_abs.sc*nspp.sc +
                     temptrend_abs.sc*thermal_bias.sc:tsign +
                     temptrend_abs.sc*npp.sc +
                     temptrend_abs.sc*veg.sc +
                     temptrend_abs.sc*duration.sc +
                     temptrend_abs.sc*human_bowler.sc:REALM2,
                   random = randef, weights = varef, data = trends[i1,], method = 'REML')
  saveRDS(modTfullbowlerrem0, file = 'temp/modTfullbowlerrem0.rds')
}

# using Venter/Halpern for human impact
if(file.exists('temp/modTfullfootprintrem0.rds')){
  modTfullfootprintrem0 <- readRDS('temp/modTfullfootprintrem0.rds')
} else {
modTfullfootprintrem0 <- lme(Jtutrendrem0 ~ temptrend_abs.sc*REALM + 
                     temptrend_abs.sc*tsign + 
                     temptrend_abs.sc*tempave_metab.sc + 
                     temptrend_abs.sc*seas.sc + 
                     temptrend_abs.sc*microclim.sc + 
                     temptrend_abs.sc*mass.sc + 
                     temptrend_abs.sc*speed.sc + 
                     temptrend_abs.sc*consumerfrac.sc +
                     temptrend_abs.sc*nspp.sc +
                     temptrend_abs.sc*thermal_bias.sc:tsign +
                     temptrend_abs.sc*npp.sc +
                     temptrend_abs.sc*veg.sc +
                     temptrend_abs.sc*duration.sc +
                     temptrend_abs.sc*human_footprint.sc:REALM2,
                   random = randef, weights = varef, data = trends[i1,], method = 'REML',
                   control = lmeControl(maxIter = 100, msMaxIter = 100, niterEM = 50, msMaxEval = 500))
  saveRDS(modTfullfootprintrem0, file = 'temp/modTfullfootprintrem0.rds')

}
AIC(modTfullbowlerrem0, modTfullfootprintrem0)

```

#### Full models
```{r LME Jacard total and MH models rem0, fig.width=10, fig.height=8}
i1 <- trends[, complete.cases(Jtutrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]
i2 <- trends[, complete.cases(Jbetatrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]
i3 <- trends[, complete.cases(Horntrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]

randef <- list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1)
varef <- varPower(-0.5, ~nyrBT)

# full models
if(file.exists('temp/modTfullJturem0.rds')){
  modTfullJturem0 <- readRDS('temp/modTfullJturem0.rds')
} else {
  modTfullJturem0 <- lme(Jtutrendrem0 ~ temptrend_abs.sc*REALM + 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*consumerfrac.sc +
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*veg.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc:REALM2,
                       random = randef, weights = varef, data = trends[i2,], method = 'REML')
  saveRDS(modTfullJturem0, file = 'temp/modTfullJturem0.rds')
}

if(file.exists('temp/modTfullJbetarem0.rds')){
  modTfullJbetarem0 <- readRDS('temp/modTfullJbetarem0.rds')
} else {
  modTfullJbetarem0 <- lme(Jbetatrendrem0 ~ temptrend_abs.sc*REALM + 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*consumerfrac.sc +
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*veg.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc:REALM2,
                       random = randef, weights = varef, data = trends[i2,], method = 'REML')
  saveRDS(modTfullJbetarem0, file = 'temp/modTfullJbetarem0.rds')
}

if(file.exists('temp/modTfullHornrem0.rds')){
  modTfullHornrem0 <- readRDS('temp/modTfullHornrem0.rds')
} else {
  modTfullHornrem0 <- lme(Horntrendrem0 ~ temptrend_abs.sc*REALM + 
                        temptrend_abs.sc*tsign +
                        temptrend_abs.sc*tempave_metab.sc + 
                        temptrend_abs.sc*seas.sc + 
                        temptrend_abs.sc*microclim.sc + 
                        temptrend_abs.sc*mass.sc + 
                        temptrend_abs.sc*speed.sc + 
                        temptrend_abs.sc*consumerfrac.sc +
                        temptrend_abs.sc*nspp.sc +
                        temptrend_abs.sc*thermal_bias.sc:tsign +
                        temptrend_abs.sc*npp.sc +
                        temptrend_abs.sc*veg.sc +
                        temptrend_abs.sc*duration.sc +
                        temptrend_abs.sc*human_bowler.sc:REALM2,
                      random = randef, weights = varef, data = trends[i3,], method = 'REML')
  saveRDS(modTfullHornrem0, file = 'temp/modTfullHornrem0.rds')
}

summary(modTfullJturem0)
summary(modTfullJbetarem0)
summary(modTfullHornrem0)

rsquared(modTfullJturem0)
rsquared(modTfullJbetarem0)
rsquared(modTfullHornrem0)

```

### Plots from the full models
#### Plot the coefficients
```{r plot fullTmods, fig.height=12, fig.width=9}

coefs1 <- summary(modTfullJturem0)$tTable
coefs2 <- summary(modTfullJbetarem0)$tTable
coefs3 <- summary(modTfullHornrem0)$tTable

varstoplot <- unique(c(rownames(coefs1), rownames(coefs2), rownames(coefs3)))
varstoplot <- varstoplot[which(!grepl('Intercept', varstoplot) | grepl(':', varstoplot))] # vars to plot

rows1_1 <- which(rownames(coefs1) %in% varstoplot) # rows in coefs
rows1_2 <- which(rownames(coefs2) %in% varstoplot)
rows1_3 <- which(rownames(coefs3) %in% varstoplot)
xlims <- range(c(coefs1[rows1_1,1] - coefs1[rows1_1,2], coefs1[rows1_1,1] + coefs1[rows1_1,2], 
                  coefs2[rows1_2,1] - coefs2[rows1_2,2], coefs2[rows1_2,1] + coefs2[rows1_2,2], 
                  coefs3[rows1_3,1] - coefs3[rows1_3,2], coefs3[rows1_3,1] + coefs3[rows1_3,2]))


cols <- brewer.pal(3, 'Dark2') # for Jtu, Jbeta and Horn models
pchs <- c(16, 16, 16)
offs <- c(0.1, 0, -0.1) # offset vertically for each model


par(las = 1, mai = c(0.5, 4, 0.1, 0.1))

plot(0,0, col = 'white', xlim = xlims, ylim = c(1,length(varstoplot)), yaxt='n', xlab = '', ylab ='')
axis(2, at = length(varstoplot):1, labels = varstoplot, cex.axis = 0.7)
abline(v = 0, col = 'grey', lty = 2)
abline(h = 1:length(varstoplot), col = 'grey', lty = 3)
for(i in 1:length(varstoplot)){
  if(varstoplot[i] %in% rownames(coefs1)){
    x = coefs1[rownames(coefs1) == varstoplot[i], 1]
    se = coefs1[rownames(coefs1) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[1], pch = pchs[1], col = cols[1])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[1], length(varstoplot) + 1 - i + offs[1]), col = cols[1])
  }
  if(varstoplot[i] %in% rownames(coefs2)){
    x = coefs2[rownames(coefs2) == varstoplot[i], 1]
    se = coefs2[rownames(coefs2) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[2], pch = pchs[2], col = cols[2])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[2], length(varstoplot) + 1 - i + offs[2]), col = cols[2])
  }
  if(varstoplot[i] %in% rownames(coefs3)){
    x = coefs3[rownames(coefs3) == varstoplot[i], 1]
    se = coefs3[rownames(coefs3) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[3], pch = pchs[3], col = cols[3])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[3], length(varstoplot) + 1 - i + offs[3]), col = cols[3])
  }
}
legend('topleft', col = cols, pch = 16, lwd = 1, legend = c('Jtu', 'Jbeta', 'Horn'), cex = 0.5)
```





#### Plot interactions (Jaccard turnover)
```{r interaction plots modTfullJturem0, fig.height = 13, fig.width = 9}

# set up the interactions to plot
# if variable is logged before scaling (see 'center and scale' above), then need to mark it here and express the limits on a log10 scale (even though log transforming is log)
ints <- data.frame(vars = c('tsign', 'tempave_metab', 'seas', 'microclim', 'mass', 'speed', 
                            'consumerfrac', 'nspp', 'thermal_bias', 'npp', 'veg', 'duration', 
                            'human_bowler', 'human_bowler'),
           min =      c(1,  0,   0.1, -2,  0,   0,   0,   0.3, -10, 1.9, 0,   0.5, 0,   0), 
           max =      c(2,  30,  16,  0.8, 8,   2,   1,   2.6, 10,  3.7, 0.3, 2,   1,   1),
           log =      c(F,  F,   F,   T,   T,   T,   F,   T,   F,   T,   T,   T,   T,   T),
           len =      c(2,  100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100),
           discrete = c(T,  F,   F,   F,   F,   F,   F,   F,   F,   F,   F,   F,   F,   F),
           plus =     c(0,  0,   0,   0,   0,   1,   0,   0,   0,   0,   1,   0,   1,   1), # what to add before log-scaling
           REALM = c(rep('Terrestrial', 12), 'Terrestrial', 'Marine'),
           REALM2 = c(rep('TerrFresh', 13), 'Marine'),
           stringsAsFactors = FALSE)
baseall <- trends[, .(type = 'all', tempave_metab.sc = mean(tempave_metab.sc, na.rm=TRUE), 
                      seas.sc = mean(seas.sc, na.rm=TRUE), 
                      microclim.sc = mean(microclim.sc, na.rm=TRUE), 
                      speed.sc = mean(speed.sc, na.rm=TRUE), 
                      mass.sc = mean(mass.sc, na.rm=TRUE), 
                      nspp.sc = 0, 
                      thermal_bias.sc = mean(thermal_bias.sc, na.rm=TRUE), 
                      npp.sc = mean(npp.sc, na.rm=TRUE), 
                      human_bowler.sc = mean(human_bowler.sc, na.rm=TRUE), 
                      veg.sc = mean(veg.sc, na.rm=TRUE), 
                      consumerfrac.sc = mean(consumerfrac.sc, na.rm=TRUE))]
baseterr <- trends[REALM == 'Terrestrial', 
                   .(type = 'Terrestrial', 
                     tempave_metab.sc = mean(tempave_metab.sc, na.rm=TRUE), 
                     seas.sc = mean(seas.sc, na.rm=TRUE), 
                     microclim.sc = mean(microclim.sc, na.rm=TRUE), 
                     speed.sc = mean(speed.sc, na.rm=TRUE), 
                     mass.sc = mean(mass.sc, na.rm=TRUE), 
                     nspp.sc = 0, 
                     thermal_bias.sc = 0, 
                     npp.sc = mean(npp.sc, na.rm=TRUE), 
                     human_bowler.sc = mean(human_bowler.sc, na.rm=TRUE), 
                     veg.sc = mean(veg.sc, na.rm=TRUE), 
                     consumerfrac.sc = mean(consumerfrac.sc, na.rm=TRUE))]
basemar <- trends[REALM == 'Marine', 
                  .(type = 'Marine',
                    tempave_metab.sc = mean(tempave_metab.sc, na.rm=TRUE), 
                    seas.sc = mean(seas.sc, na.rm=TRUE), 
                    microclim.sc = mean(microclim.sc, na.rm=TRUE), 
                    speed.sc = mean(speed.sc, na.rm=TRUE), 
                    mass.sc = mean(mass.sc, na.rm=TRUE), 
                    nspp.sc = 0, 
                    thermal_bias.sc = 0, 
                    npp.sc = mean(npp.sc, na.rm=TRUE), 
                    human_bowler.sc = mean(human_bowler.sc, na.rm=TRUE), 
                    veg.sc = mean(veg.sc, na.rm=TRUE), 
                    consumerfrac.sc = mean(consumerfrac.sc, na.rm=TRUE))]
basetab <- rbind(baseall, baseterr, basemar)
basetab[, ':='(duration.sc = 0, nyrBT = 20, STUDY_ID = 127L, rarefyID = '127_514668')]

# make the data frames for each interaction to plot                
for(j in 1:nrow(ints)){
  # set up a grid of temperature trends and the interacting variable
  if(ints$log[j]) intvars <- list(temptrend = seq(-1.5, 1.5, length.out = 100), 
                                  new = 10^seq(ints$min[j], ints$max[j], length.out = ints$len[j]),
                                   var = ints$vars[j])
  if(!ints$log[j]) intvars <- list(temptrend = seq(-1.5, 1.5, length.out = 100), 
                                   new = seq(ints$min[j], ints$max[j], length.out = ints$len[j]),
                                   var = ints$vars[j])
  names(intvars) <- c('temptrend', ints$vars[j], 'var')
  thisdat <- expand.grid(intvars)
  
  # scale the interacting variable
  cent <- attr(trends[[paste0(ints$var[j], '.sc')]], 'scaled:center')
  scl <- attr(trends[[paste0(ints$var[j], '.sc')]], 'scaled:scale')
  if(!is.null(cent) & !is.null(scl)){
    if(ints$log[j]) thisdat[[paste0(ints$var[j], '.sc')]] <- (log(thisdat[[ints$vars[j]]] + ints$plus[j]) - cent)/scl
    if(!ints$log[j]) thisdat[[paste0(ints$var[j], '.sc')]] <- (thisdat[[ints$var[j]]] - cent)/scl
  }

  # merge with the rest of the columns
  # use realm-specific averages for human impacts
  if(ints$vars[j] != 'tsign') colnamestouse <- setdiff(colnames(basetab), paste0(ints$var[j], '.sc'))
  if(ints$vars[j] == 'tsign') colnamestouse <- setdiff(colnames(basetab), ints$var[j])
  if(ints$vars[j] != 'human_bowler'){
    thisdat <- cbind(thisdat, basetab[type == 'all', ..colnamestouse])
  }
  if(ints$vars[j] == 'human_bowler' & ints$REALM[j] == 'Terrestrial'){
    thisdat <- cbind(thisdat, basetab[type == 'Terrestrial', ..colnamestouse])
  }
  if(ints$vars[j] == 'human_bowler' & ints$REALM[j] == 'Marine'){
    thisdat <- cbind(thisdat, basetab[type == 'Marine', ..colnamestouse])
  }
  
  # add realm
  thisdat$REALM <- ints$REALM[j]
  thisdat$REALM2 <- ints$REALM2[j]
  
  # merge with the previous iterations
  if(j == 1) newdat <- thisdat
  if(j > 1){
    colstoadd <- setdiff(colnames(thisdat), colnames(newdat))
    for(toadd in colstoadd){
      newdat[[toadd]] <- NA
    }
    
    colstoadd2 <- setdiff(colnames(newdat), colnames(thisdat))
    for(toadd in colstoadd2){
      thisdat[[toadd]] <- NA
    }
    
    newdat <- rbind(newdat, thisdat)
  } 
}

# character so that new levels can be added
newdat$REALM <- as.character(newdat$REALM)
newdat$REALM2 <- as.character(newdat$REALM2)

# add extra rows so that all factor levels are represented (for predict.lme to work)
newdat <- rbind(newdat[1:6, ], newdat)
newdat$REALM[1:6] <- c('Marine', 'Marine', 'Freshwater', 'Freshwater', 'Terrestrial', 'Terrestrial')
newdat$REALM2[1:6] <- c('Marine', 'Marine', 'TerrFresh', 'TerrFresh', 'TerrFresh', 'TerrFresh')
newdat$temptrend[1:6] <- c(-1, 1, -1, 1, -1, 1)

# trim to at least some temperature change (so that tsign is -1 or 1)
newdat <- newdat[newdat$temptrend != 0,]

# scale the temperature vars
newdat$temptrend.sc <- newdat$temptrend/attr(trends$temptrend.sc, 'scaled:scale') 
newdat$temptrend_abs <- abs(newdat$temptrend)
newdat$temptrend_abs.sc <- (newdat$temptrend_abs)/attr(trends$temptrend_abs.sc, 'scaled:scale')
newdat$tsign <- factor(sign(newdat$temptrend))

# make predictions
newdat$preds <- predict(object = modTfullJturem0, newdata = newdat, level = 0)

#remove the extra rows
newdat <- newdat[5:nrow(newdat), ]

# prep the plots
intplots <- vector('list', nrow(ints))
for(j in 1:length(intplots)){
  subs <- newdat$var == ints$vars[j] & newdat$temptrend > 0 # select warming side
  xvar <- 'temptrend_abs'
  title <- ints$vars[j]
  if(ints$vars[j] %in% c('tsign')){
    subs <- newdat$var == ints$vars[j]
  } 
  if(ints$vars[j] %in% c('thermal_bias')){
    subs <- newdat$var == ints$vars[j]
    xvar <- 'temptrend'
  } 
  if(ints$vars[j] %in% c('human_bowler')){
    subs <- newdat$var == ints$vars[j] & newdat$temptrend > 0 & newdat$REALM2 == ints$REALM2[j]
    title <- paste0('human:', ints$REALM2[j])
  } 

  thisplot <- ggplot(newdat[subs, ], 
                     aes_string(x = xvar, y = 'preds', 
                                group = ints$vars[j], 
                                color = ints$vars[j])) +
    geom_line() +
    coord_cartesian(ylim = c(-0.2, 0.4)) +
    theme(plot.margin = unit(c(0.5,0,0.5,0), 'cm')) +
    labs(title = title)
  if(ints$log[j] & !ints$discrete[j]){
    intplots[[j]] <- thisplot + scale_color_distiller(palette = "YlGnBu", trans = 'log')
  }
  if(!ints$log[j] & !ints$discrete[j]){
    intplots[[j]] <- thisplot + scale_color_distiller(palette = "YlGnBu", trans = 'identity')
  }
  if(ints$discrete[j]){
    intplots[[j]] <- thisplot + scale_color_brewer(palette = "Dark2")
  }
}

#grid.arrange(grobs = intplots, '+', theme(plot.margin = unit(c(0,0,0,0), 'cm'))), ncol=2)
#do.call('grid.arrange', c(intplots, ncol = 2))
grid.arrange(grobs = intplots, ncol = 3)

# write out the interactions
write.csv(newdat, file = 'temp/interactions.csv')

```

#### Plot residuals against each predictor (Jaccard turnover)
```{r resids modTfull1, fig.height = 10, fig.width=10}
resids <- resid(modTfullJturem0)
preds <- getData(modTfullJturem0)
col = '#00000033'
cex = 0.5
par(mfrow = c(5,4))
boxplot(resids ~ preds$REALM, cex = cex, col = col)
plot(preds$temptrend_abs.sc, resids, cex = cex, col = col)
plot(preds$tsign, resids, cex = cex, col = col)
plot(preds$tempave.sc, resids, cex = cex, col = col)
plot(preds$tempave_metab.sc, resids, cex = cex, col = col)
plot(preds$seas.sc, resids, cex = cex, col = col)
plot(preds$microclim.sc, resids, cex = cex, col = col)
plot(preds$mass.sc, resids, cex = cex, col = col)
plot(preds$speed.sc, resids, cex = cex, col = col)
plot(preds$lifespan.sc, resids, cex = cex, col = col)
plot(preds$consumerfrac.sc, resids, cex = cex, col = col)
plot(preds$endothermfrac.sc, resids, cex = cex, col = col)
plot(preds$nspp.sc, resids, cex = cex, col = col)
plot(preds$thermal_bias.sc, resids, cex = cex, col = col)
plot(preds$npp.sc, resids, cex = cex, col = col)
plot(preds$veg.sc, resids, cex = cex, col = col)
plot(preds$human_bowler.sc, resids, cex = cex, col = col)
```

### Remove each term from the full model
```{r term deletion from modTfull}
AICnas <- function(x){
  if(class(x) == 'NULL'){
    return(NA)
  } else {
    return(AIC(x))
  }
}

if(file.exists('output/aics_from_full.csv')){
  aicsfromfull <- read.csv('output/aics_from_full.csv')
  
  if('dAIC_Jtu' %in% colnames(aicsfromfull)){
    runJtu <- FALSE
  } else {
    runJtu <- TRUE
  }
  
  if('dAIC_Jbeta' %in% colnames(aicsfromfull)){
    runJbeta <- FALSE
  } else {
    runJbeta <- TRUE
  }
  
  if('dAIC_Horn' %in% colnames(aicsfromfull)){
    runHorn <- FALSE
  } else {
    runHorn <- TRUE
  }
  
} else {
  runJtu <- TRUE
  runJbeta <- TRUE
  runHorn <- TRUE
}

randef <- list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1)
varef <- varPower(-0.5, ~nyrBT)

terms <- c('temptrend_abs.sc*REALM', 
           'temptrend_abs.sc*tsign',
           'temptrend_abs.sc*tempave_metab.sc',
           'temptrend_abs.sc*seas.sc',
           'temptrend_abs.sc*microclim.sc',
           'temptrend_abs.sc*mass.sc',
           'temptrend_abs.sc*speed.sc', 
           'temptrend_abs.sc*consumerfrac.sc',
           'temptrend_abs.sc*nspp.sc',
           'temptrend_abs.sc*thermal_bias.sc:tsign',
           'temptrend_abs.sc*npp.sc',
           'temptrend_abs.sc*veg.sc',
           'temptrend_abs.sc*duration.sc',
           'temptrend_abs.sc*human_bowler.sc:REALM2')


if(runJtu){
  i <- trends[, complete.cases(Jtutrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                               temptrend_abs.sc, mass.sc, speed.sc, 
                               consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                               veg.sc, duration.sc, human_bowler.sc)]
  
  modTdrops <- vector('list', length(terms)+2)
  names(modTdrops) <- c('full', '-temptrend_abs.sc', paste0('-', terms))
  
  # fit full model with ML for model comparison
  modTdrops[[1]] <- lme(formula(paste0('Jtutrendrem0 ~ ', paste(terms, collapse = ' + '))),
                        random = randef, weights = varef, data = trends[i,], method = 'ML')
  
  # w/out temptrend
  modTdrops[[2]] <- lme(formula(paste0('Jtutrendrem0 ~ ', paste(gsub('temptrend_abs.sc\\*', '', terms), collapse = ' + '))),
                        random = list(STUDY_ID = ~ 1, rarefyID = ~1), weights = varef, data = trends[i,], method = 'ML')
  
  for(j in 1:length(terms)){
    print(j)
    tryCatch({
      modTdrops[[j+2]] <- lme(formula(paste0('Jtutrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                              random = randef, weights = varef, data = trends[i,], method = 'ML')
      
    }, error = function(e){
      print('going to optim (Jtu)')
      tryCatch({
        modTdrops[[j+2]] <- lme(formula(paste0('Jtutrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                random = randef, weights = varef, data = trends[i,], method = 'ML',
                                control = lmeControl(opt = 'optim'))
        
      }, error = function(e){
        print('going to more iters (Jtu)') 
        tryCatch({
          modTdrops[[j+2]] <- lme(formula(paste0('Jtutrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                  random = randef, weights = varef, data = trends[i,], method = 'ML',
                                  control = lmeControl(maxIter = 100, msMaxIter = 100, niterEM = 50, msMaxEval = 500))
          
        }, error= function(e){
          print('giving up on this one')
          modTdrops[[j+2]] <- NA
        })
      })
    })
  }
  
  aicsJtu <- sapply(modTdrops, AICnas)
}


if(runJbeta){
  i <- trends[, complete.cases(Jbetatrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                               temptrend_abs.sc, mass.sc, speed.sc, 
                               consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                               veg.sc, duration.sc, human_bowler.sc)]
  
  modTJbetadrops <- vector('list', length(terms)+2)
  names(modTJbetadrops) <- c('full', '-temptrend_abs.sc', paste0('-', terms))
  
  # fit full model with ML for model comparison
  modTJbetadrops[[1]] <- lme(formula(paste0('Jbetatrendrem0 ~ ', paste(terms, collapse = ' + '))),
                             random = randef, weights = varef, data = trends[i,], method = 'ML')
  
  # w/out temptrend
  modTJbetadrops[[2]] <- lme(formula(paste0('Jbetatrendrem0 ~ ', paste(gsub('temptrend_abs.sc\\*', '', terms), collapse = ' + '))),
                             random = list(STUDY_ID = ~ 1, rarefyID = ~1), weights = varef, data = trends[i,], method = 'ML')
  
  for(j in 1:length(terms)){
    print(j)
    tryCatch({
      modTJbetadrops[[j+2]] <- lme(formula(paste0('Jbetatrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                   random = randef, weights = varef, data = trends[i,], method = 'ML')
    }, error = function(e){
      print('going to optim (Jbeta)')
      tryCatch({
        modTJbetadrops[[j+2]] <- lme(formula(paste0('Jbetatrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                     random = randef, weights = varef, data = trends[i,], method = 'ML',
                                     control = lmeControl(opt = 'optim'))
        
      }, error = function(e){
        print('going to more iters (Jbeta)') 
        tryCatch({
          modTJbetadrops[[j+2]] <- lme(formula(paste0('Jbetatrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                       random = randef, weights = varef, data = trends[i,], method = 'ML',
                                       control = lmeControl(maxIter = 100, msMaxIter = 100, 
                                                            niterEM = 50, msMaxEval = 500))
        }, error= function(e){
          print('giving up on this one (Jbeta)')
          modTJbetadrops[[j+2]] <- NA
        })
      }
      )
    }
    )
  }
  aicsJbeta <- sapply(modTJbetadrops, AICnas)
}

if(runHorn){
  i2 <- trends[, complete.cases(Horntrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                                temptrend_abs.sc, mass.sc, speed.sc, 
                                consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                                veg.sc, duration.sc, human_bowler.sc)]
  
  modTHorndrops <- vector('list', length(terms)+2)
  names(modTHorndrops) <- c('full', '-temptrend_abs.sc', paste0('-', terms))
  modTHorndrops[[1]] <- lme(formula(paste0('Horntrendrem0 ~ ', paste(terms, collapse = ' + '))),
                            random = randef, weights = varef, data = trends[i2,], method = 'ML')
  modTHorndrops[[2]] <- lme(formula(paste0('Horntrendrem0 ~ ', paste(gsub('temptrend_abs.sc\\*', '', terms), collapse = ' + '))),
                            random = list(STUDY_ID = ~ 1, rarefyID = ~1), weights = varef, data = trends[i2,], method = 'ML')
  
  for(j in 1:length(terms)){
    print(j)
    tryCatch({
      modTHorndrops[[j+2]] <- lme(formula(paste0('Horntrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                  random = randef, weights = varef, data = trends[i2,], method = 'ML')
    }, error = function(e){
      print('going to optim (Horn)')
      tryCatch({
        modTHorndrops[[j+2]] <- lme(formula(paste0('Horntrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                    random = randef, weights = varef, data = trends[i2,], method = 'ML',
                                    control = lmeControl(opt = 'optim'))
        
      }, error = function(e){
        print('going to more iters (Horn)') 
        tryCatch({
          modTHorndrops[[j+2]] <- lme(formula(paste0('Horntrendrem0 ~ ', paste(terms[-j], collapse = ' + '))),
                                      random = randef, weights = varef, data = trends[i2,], method = 'ML',
                                      control = lmeControl(maxIter = 100, msMaxIter = 100, 
                                                           niterEM = 50, msMaxEval = 500))
          
        }, error= function(e){
          print('giving up on this one (Horn)')
          modTHorndrops[[j+2]] <- NA
        })
      })
    })
  }
  aicsHorn <- sapply(modTHorndrops, AICnas)
}

# if there was anything new
if(runJtu | runJbeta | runHorn){
  if(!exists('aicsfromfull')){
    aicsfromfull <- data.frame(mod = names(aicsJtu))
  }
  
  # subtract full from each model AIC. Negative means term removal is supported. Positive means full is the better model.
  if(runJtu){
    aicsfromfull$dAIC_Jtu <- aicsJtu - aicsJtu[1]
  }
  if(runJbeta){
    aicsfromfull$dAIC_Jbeta <- aicsJbeta - aicsJbeta[1]
  }
  if(runHorn){
    aicsfromfull$dAIC_Horn <- aicsHorn - aicsHorn[1]
  }
  
  # write out
  write.csv(aicsfromfull, file = 'output/aics_from_full.csv', row.names = FALSE)
}

aicsfromfull
```

#### Plot deltaAICs for all 3 models
```{r plot dAICs}
# transform for a plot
aicsfromfulllong <- reshape(aicsfromfull, direction = 'long',
                            varying = c('dAIC_Jtu', 'dAIC_Jbeta', 'dAIC_Horn'),
                            v.names = 'dAIC',
                            idvar = 'mod',
                            timevar = 'type',
                            times = c('Jtu', 'Jbeta', 'Horn'))

trans = function(x) sign(x)*sqrt(abs(x))
aicsfromfulllong$dAIC_tr <- trans(aicsfromfulllong$dAIC)

# plot
xlims <- range(aicsfromfulllong$dAIC_tr, na.rm = TRUE)
xticks <- c(-10, 0, 10, 100, 1000, 10000)
par(mai = c(0.5, 3, 0.1, 0.1))
with(aicsfromfulllong[aicsfromfulllong$type == 'Jtu',], plot(dAIC_tr, nrow(aicsfromfull):1, 
                                                           col = 'light grey', xlim = xlims, yaxt = 'n', ylab = '', xaxt = 'n'))
with(aicsfromfulllong[aicsfromfulllong$type == 'Jbeta',], points(dAIC_tr, nrow(aicsfromfull):1 - 0.1, col = 'dark grey'))
with(aicsfromfulllong[aicsfromfulllong$type == 'Horn',], points(dAIC_tr, nrow(aicsfromfull):1 - 0.2, col = 'black'))
axis(2, at = nrow(aicsfromfull):1, labels = aicsfromfull$mod, las = 1, cex.axis = 0.7)
axis(1, at = trans(xticks), labels = xticks, cex.axis = 0.5)
abline(v = 0, lty =2, col = 'grey')
```

Light grey is for Jaccard turnover, dark grey is for Jaccard total, black is for Morisita-Horn.
Clear that removing temperature trend makes the model quite a bit worse and has the biggest effect.



## Simplify the full models
This takes a couple days on a laptop to run if temp/ files not available.
```{r simplify the full models}
i1 <- trends[, complete.cases(Jtutrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]
i2 <- trends[, complete.cases(Jbetatrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]
i3 <- trends[, complete.cases(Horntrendrem0, REALM, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]

randef <- list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1)
varef <- varPower(-0.5, ~nyrBT)

# simplify the full models
if(file.exists('temp/modTsimpJturem0.rds')){
  modTsimpJturem0 <- readRDS('temp/modTsimpJturem0.rds')
} else {
  modTfullJturem0ML <- lme(Jtutrendrem0 ~ temptrend_abs.sc*REALM + 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*consumerfrac.sc +
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*veg.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc:REALM2,
                       random = randef, weights = varef, data = trends[i1,], method = 'ML',
                       control = lmeControl(maxIter = 100, msMaxIter = 100, niterEM = 50, msMaxEval = 500))
  modTsimpJturem0 <- stepAIC(modTfullJturem0ML, direction = 'backward')
  saveRDS(modTsimpJturem0, file = 'temp/modTsimpJturem0.rds')
}

if(file.exists('temp/modTsimpJbetarem0.rds')){
  modTsimpJbetarem0 <- readRDS('temp/modTsimpJbetarem0.rds')
} else {
  modTfullJbetarem0ML <- lme(Jbetatrendrem0 ~ temptrend_abs.sc*REALM + 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*consumerfrac.sc +
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*veg.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc:REALM2,
                       random = randef, weights = varef, data = trends[i2,], method = 'ML')
  modTsimpJbetarem0 <- stepAIC(modTfullJbetarem0ML, direction = 'backward')
  saveRDS(modTsimpJbetarem0, file = 'temp/modTsimpJbetarem0.rds')
}

if(file.exists('temp/modTsimpHornrem0.rds')){
  modTsimpHornrem0 <- readRDS('temp/modTsimpHornrem0.rds')
} else {
  modTfullHornrem0ML <- lme(Horntrendrem0 ~ temptrend_abs.sc*REALM + 
                        temptrend_abs.sc*tsign +
                        temptrend_abs.sc*tempave_metab.sc + 
                        temptrend_abs.sc*seas.sc + 
                        temptrend_abs.sc*microclim.sc + 
                        temptrend_abs.sc*mass.sc + 
                        temptrend_abs.sc*speed.sc + 
                        temptrend_abs.sc*consumerfrac.sc +
                        temptrend_abs.sc*nspp.sc +
                        temptrend_abs.sc*thermal_bias.sc:tsign +
                        temptrend_abs.sc*npp.sc +
                        temptrend_abs.sc*veg.sc +
                        temptrend_abs.sc*duration.sc +
                        temptrend_abs.sc*human_bowler.sc:REALM2,
                      random = randef, weights = varef, data = trends[i3,], method = 'ML')
  modTsimpHornrem0 <- stepAIC(modTfullHornrem0ML, direction = 'backward')
  saveRDS(modTsimpHornrem0, file = 'temp/modTsimpHornrem0.rds')
}

summary(modTsimpJturem0)
summary(modTsimpJbetarem0)
summary(modTsimpHornrem0)


```


## Make realm-specific models
```{r LME Horn models by realm, fig.width=10, fig.height=8}
i1 <- trends[, REALM == 'Terrestrial' & complete.cases(Horntrendrem0, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)]
i2 <- trends[, REALM == 'Freshwater' & complete.cases(Horntrendrem0, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             nspp.sc, thermal_bias.sc, npp.sc, 
                             veg.sc, duration.sc, human_bowler.sc)] # no consumerfrac
i3 <- trends[, REALM == 'Marine' & complete.cases(Horntrendrem0, tempave_metab.sc, seas.sc, microclim.sc, 
                             temptrend_abs.sc, mass.sc, speed.sc, 
                             consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, 
                             duration.sc, human_bowler.sc)] # no veg

print(paste('Terrestrial', sum(i1)))
print(paste('Freshwater', sum(i2)))
print(paste('Marine', sum(i3)))

randef <- list(STUDY_ID = ~ temptrend_abs.sc, rarefyID = ~1)
varef <- varPower(-0.5, ~nyrBT)

# land
if(file.exists('temp/modTfullHornTerr.rds')){
  modTfullHornTerr <- readRDS('temp/modTfullHornTerr.rds')
} else {
  modTfullHornTerr <- lme(Horntrendrem0 ~ 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*consumerfrac.sc +
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*veg.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc,
                       random = randef, weights = varef, data = trends[i1,], method = 'REML',
                       control = lmeControl(maxIter = 100, msMaxIter = 100, niterEM = 50, msMaxEval = 500))
  saveRDS(modTfullHornTerr, file = 'temp/modTfullHornTerr.rds')
}

# freshwater
if(file.exists('temp/modTfullHornFresh.rds')){
  modTfullHornFresh <- readRDS('temp/modTfullHornFresh.rds')
} else {
  modTfullHornFresh <- lme(Horntrendrem0 ~ 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*veg.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc,
                       random = randef, weights = varef, data = trends[i2,], method = 'REML')
  saveRDS(modTfullHornFresh, file = 'temp/modTfullHornFresh.rds')
}

# marine
if(file.exists('temp/modTfullHornMar.rds')){
  modTfullHornMar <- readRDS('temp/modTfullHornMar.rds')
} else {
  modTfullHornMar <- lme(Horntrendrem0 ~ 
                         temptrend_abs.sc*tsign +
                         temptrend_abs.sc*tempave_metab.sc + 
                         temptrend_abs.sc*seas.sc + 
                         temptrend_abs.sc*microclim.sc + 
                         temptrend_abs.sc*mass.sc + 
                         temptrend_abs.sc*speed.sc + 
                         temptrend_abs.sc*consumerfrac.sc +
                         temptrend_abs.sc*nspp.sc +
                         temptrend_abs.sc*thermal_bias.sc:tsign +
                         temptrend_abs.sc*npp.sc +
                         temptrend_abs.sc*duration.sc +
                         temptrend_abs.sc*human_bowler.sc,
                       random = randef, weights = varef, data = trends[i3,], method = 'REML')
  saveRDS(modTfullHornMar, file = 'temp/modTfullHornMar.rds')
}

summary(modTfullHornTerr)
summary(modTfullHornFresh)
summary(modTfullHornMar)
```
### Plot the realm-specific coefficients
Also uses the full models across all realms
```{r plot realm mods, fig.height=12, fig.width=9}

coefs1 <- summary(modTfullHornrem0)$tTable
coefs2 <- summary(modTfullHornTerr)$tTable
coefs3 <- summary(modTfullHornFresh)$tTable
coefs4 <- summary(modTfullHornMar)$tTable

varstoplot <- unique(c(rownames(coefs1), rownames(coefs2), rownames(coefs3), rownames(coefs4)))
varstoplot <- varstoplot[which(!grepl('Intercept', varstoplot) | grepl(':', varstoplot))] # vars to plot

rows1_1 <- which(rownames(coefs1) %in% varstoplot) # rows in coefs
rows1_2 <- which(rownames(coefs2) %in% varstoplot)
rows1_3 <- which(rownames(coefs3) %in% varstoplot)
rows1_4 <- which(rownames(coefs4) %in% varstoplot)
xlims <- range(c(coefs1[rows1_1,1] - coefs1[rows1_1,2], coefs1[rows1_1,1] + coefs1[rows1_1,2], 
                 coefs2[rows1_2,1] - coefs2[rows1_2,2], coefs2[rows1_2,1] + coefs2[rows1_2,2], 
                 coefs3[rows1_3,1] - coefs3[rows1_3,2], coefs3[rows1_3,1] + coefs3[rows1_3,2],
                 coefs4[rows1_4,1] - coefs4[rows1_4,2], coefs4[rows1_4,1] + coefs4[rows1_4,2]))


cols <- brewer.pal(4, 'Dark2') # for full, terr, fresh, mar
pchs <- c(1, 16, 16, 16)
offs <- c(0.1, 0, -0.1, -0.2) # offset vertically for each model


par(las = 1, mai = c(0.5, 4, 0.1, 0.1))

plot(0,0, col = 'white', xlim = xlims, ylim = c(1,length(varstoplot)), yaxt='n', xlab = '', ylab ='')
axis(2, at = length(varstoplot):1, labels = varstoplot, cex.axis = 0.7)
abline(v = 0, col = 'grey', lty = 2)
abline(h = 1:length(varstoplot), col = 'grey', lty = 3)
for(i in 1:length(varstoplot)){
  if(varstoplot[i] %in% rownames(coefs1)){
    x = coefs1[rownames(coefs1) == varstoplot[i], 1]
    se = coefs1[rownames(coefs1) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[1], pch = pchs[1], col = cols[1])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[1], length(varstoplot) + 1 - i + offs[1]), col = cols[1])
  }
  if(varstoplot[i] %in% rownames(coefs2)){
    x = coefs2[rownames(coefs2) == varstoplot[i], 1]
    se = coefs2[rownames(coefs2) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[2], pch = pchs[2], col = cols[2])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[2], length(varstoplot) + 1 - i + offs[2]), col = cols[2])
  }
  if(varstoplot[i] %in% rownames(coefs3)){
    x = coefs3[rownames(coefs3) == varstoplot[i], 1]
    se = coefs3[rownames(coefs3) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[3], pch = pchs[3], col = cols[3])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[3], length(varstoplot) + 1 - i + offs[3]), col = cols[3])
  }
  if(varstoplot[i] %in% rownames(coefs4)){
    x = coefs4[rownames(coefs4) == varstoplot[i], 1]
    se = coefs4[rownames(coefs4) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[4], pch = pchs[4], col = cols[4])
    lines(x = c(x-se, x+se), y = c(length(varstoplot) + 1 - i + offs[4], length(varstoplot) + 1 - i + offs[4]), col = cols[4])
  }
}
legend('bottomleft', col = cols, pch = pchs, lwd = 1, legend = c('All', 'Terestrial', 'Freshwater', 'Marine'))
```

[End text in hopes this helps the last figure show up when knitted]