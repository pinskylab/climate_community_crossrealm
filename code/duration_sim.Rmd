---
title: "Demonstration of the correlation generated by similar durations"
output: 
    github_document: default
---

```{r setup, echo = FALSE}
require(data.table)
require(ggplot2)
require(ggpubr) # for ggarrange
library(here)
library(glmmTMB)
library(mgcv, lib.loc = "/usr/lib64/R/library") # for gam in geom_smooth to work

# transformation for 2 categories. Eq. 1 in Douma & Weedon 2019 MEE
transform01 <- function(x) (x * (length(x) - 1) + 0.5) / (length(x))

# binomial ci
binomci <- function(x, n){
    out <- as.numeric(binom.test(x, n)$conf.int)
    return(list(out[1], out[2]))
}

```

# Plot an example of false positives
Dataset is 1000 timeseries of differing durations from 3 to 102 observations through time. The response variable is positively related to time (random slope 0.005 to 0.01) with Gaussian noise and an inverse-logit transform to constrain it to 0-1. The explanatory variables are time and the slope of a Gaussian time-series of the same durations. Time but not the slope should be related to the response.  
Two-stage regressions have a false positive.  
One-stage regression may as well.  
The shorter response time-series have steeper slopes (2nd to last graph), probably because the slope of the response vs. time is great enough to hit 1 often in longer ts. Shorter time-series do have steeper slopes if the response hits 1 less often (e.g., if random slopes only go up to 0.01).  
The shorter explanatory time-series have steeper abs(slopes), also as expected (last graph).
```{r}
set.seed(5)
slope <- function(x){
    mod <- lm(x ~ I(1:length(x)))
    return(as.numeric(coef(mod)[2]))
}
slopese <- function(x){
    mod <- lm(x ~ I(1:length(x)))
    return(as.numeric(sqrt(diag(vcov(mod)))[2]))
}

dat <- data.table(tsid = rep(1:1000, rep(3:102, 1000/100)))
dat[, ':='(obsid = 1:.N, tslope = runif(1, 0.005, 0.1)), by = tsid] # add time counter and a random slope for each tsid
dat[, ':='(value1.logit = obsid*tslope + rnorm(.N), value2 = rnorm(.N))] # create random ts. value1 has a positive slope like dissimilarites and is on a logit scale.
dat[, value1 := exp(value1.logit)/(exp(value1.logit)+1)] # inverse-logit for value 1
dat[, ':='(slope2_abs = abs(slope(value2)), duration = .N), by = tsid] # explanatory slopes for one-stage model
slopes <- dat[, .(slope1 = slope(value1), slope2_abs = abs(slope(value2)),
                  se1 = slopese(value1), duration = .N), by = tsid]

print('CORRELATION TEST')
slopes[, cor.test(slope1, slope2_abs)] # a problem with simple correlation in this example
print('WEIGHTED REGRESSION')
slopes[, summary(lm(slope1 ~ slope2_abs, weights = 1/se1))] # problem not solved by weighting
print('WEIGHTED GLMM')
slopes[, summary(glmmTMB(slope1 ~ slope2_abs, disp=~se1))] # not solved by glmmTMB and dispersion
print('ONE-STAGE GLMM')
dat[, summary(glmmTMB(value1 ~ obsid + obsid:slope2_abs + (obsid|tsid)))] # maybe addressed by a one-stage model

slopes[, plot(slope2_abs, slope1, main = 'Induced correlation of the slopes')]
dat[, .(max = max(value1), duration = duration), by = tsid][, plot(duration, max, main = 'Maximum value asymptote')]
ggplot(slopes, aes(duration, slope1)) +
    geom_point() +
    geom_smooth() +
    labs(title = 'Variance in slopes declines with duration')
ggplot(slopes, aes(duration, slope1)) +
    geom_smooth() +
    labs(title = 'Average slope declines with duration (response variable)')
ggplot(slopes, aes(duration, slope2_abs)) +
    geom_smooth() +
    labs(title = 'Average slope declines with duration (explanatory variable')
```

# Plot an example of true positives
Dataset is 1000 timeseries of differing durations from 3 to 102 observations through time. The response variable is positively related to time (random slope 0.005 to 0.01, called 'tslope') AND the explanatory variable (abs value of Gaussian) with Gaussian noise and an inverse-logit transform to constrain it to 0-1. The explanatory variables are time and the slope of a Gaussian time-series of the same durations. Time and explanatory variable should be related to the response.  

```{r}
set.seed(5)
slope <- function(x){
    mod <- lm(x ~ I(1:length(x)))
    return(as.numeric(coef(mod)[2]))
}
slopese <- function(x){
    mod <- lm(x ~ I(1:length(x)))
    return(as.numeric(sqrt(diag(vcov(mod)))[2]))
}

dat <- data.table(tsid = rep(1:1000, rep(3:102, 1000/100)))
dat[, ':='(obsid = 1:.N, tslope = runif(1, 0.005, 0.1), value2 = rnorm(.N), duration = .N, e = rnorm(.N, 0, 0.1)), by = tsid] # add time counter, a random temporal slope for each tsid, a random explanatory variable, and error
dat[, slope2_abs := abs(slope(value2)), by = tsid]
dat[, ':='(value1.logit = obsid*tslope + 0.5*tslope*obsid*slope2_abs + e)] # value1 has a positive slope like dissimilarites and is on a logit scale. Positively related to slope2.
dat[, value1 := exp(value1.logit)/(exp(value1.logit)+1)] # inverse-logit for value 1
slopes <- dat[, .(slope1 = slope(value1), slope2_abs = unique(slope2_abs),
                  se1 = slopese(value1), duration = .N), by = tsid]

ggplot(slopes, aes(slope2_abs, slope1, color = duration)) + geom_point() + geom_smooth()
ggplot(dat[, .(max = max(value1), duration = unique(duration), tslope = unique(tslope)), by = tsid], aes(duration, max, color = tslope)) +
    geom_point() +
    labs(title = 'Visualize the duration effect: maxes out at 1. Tslope is the slope vs. time')

```

# False positive analysis
Generate pairs of random time-series and correlate the slopes. Time-series have a fixed length or a variety of lengths from 3 to 102 steps. The response time-series is constrained 0-1. Do this many times to check for false-positive correlations using cor.test, a weighted linear regression, and a one-stage mixed-effects analysis with Gaussian or Beta errors.  

Only the one-stage regression with beta errors appears to have a reasonable false-positive rate.
```{r,message=FALSE, warning=FALSE, results='hide', echo = FALSE}
if(!file.exists(here('output', 'simulated_ts.csv.gz'))){
    stop('Need to run duration_sim.R first.')
} else {
    #cors <- fread(here('temp', 'simulated_ts_temp.csv.gz')) # the in-progress analysis
    cors <- fread(here('output', 'simulated_ts.csv.gz')) # the full analysis
    
    ylims = c(-10, 0)
    normparms <- cors[, .(mean = mean(lm.m), sd = sd(lm.m)), by = range] # parameters for Gaussian curves on each histogram
    x <- seq(-1,1,length.out = 1000)
    
    cors[range == 0, hist(lm.m, breaks = 40, xlab = 'Correlation slopes', main = 'Range = 0', freq = FALSE)]; normparms[range == 0, lines(x, dnorm(x,mean, sd))]
    cors[range == 9, hist(lm.m, breaks = 40, xlab = 'Correlation slopes', main = 'Range = 9', freq = FALSE)]; normparms[range == 9, lines(x, dnorm(x,mean, sd))]
    cors[range == 24, hist(lm.m, breaks = 40, xlab = 'Correlation slopes', main = 'Range = 24', freq = FALSE)]; normparms[range == 24, lines(x, dnorm(x,mean, sd))]
    cors[range == 49, hist(lm.m, breaks = 40, xlab = 'Correlation slopes', main = 'Range = 49', freq = FALSE)]; normparms[range == 49, lines(x, dnorm(x,mean, sd))]
    cors[range == 99, hist(lm.m, breaks = 40, xlab = 'Correlation slopes', main = 'Range = 99', freq = FALSE)]; normparms[range == 99, lines(x, dnorm(x,mean, sd))]
    
    corsl <- melt(cors, id.vars = c('n', 'minduration', 'maxduration', 'name', 'range'), measure.vars = c('cor.p', 'cor.cor', 'lm.m', 'glmmwgt.p', 'glmmwgt.beta', 'glmmonegauss.p', 'glmmonegauss.beta', 'glmmonebeta.p', 'glmmonebeta.beta'))
    
    prop <- corsl[variable %in% c('cor.p', 'glmmwgt.p', 'glmmonegauss.p', 'glmmonebeta.p'), 
                  .(nsims = sum(!is.na(value)), prop = sum(value < 0.05, na.rm=TRUE)/sum(!is.na(value), na.rm=TRUE)), by = c("range", "n", "variable")]
    prop[, c("lower", "upper") := binomci(nsims*prop, nsims), by = .(range, n, variable)]
    
    ggplot(cors, aes(range, log10(cor.p), group = as.factor(n), color = as.factor(n))) +
        geom_point() +
        geom_smooth() +
        labs(x = 'Range of durations', title = 'Correlation') +
        lims(y = ylims) +
        geom_abline(intercept = log10(0.05), slope = 0, linetype = 'dashed', color = 'red')
    
    dg = position_dodge(5)
    ggplot(prop, aes(range, prop, group = variable, color = variable)) +
        geom_line(position = dg) +
        geom_point(position = dg) +
        geom_errorbar(aes(ymin=lower, ymax=upper), width=.1, position = dg) +
        labs(x = 'Range of durations', title = 'Overall comparison of false positive rates', y = 'Proportion false positive') +
        lims(y = c(0,1)) +
        geom_abline(intercept = 0.05, slope = 0, linetype = 'dashed', color = 'red') +
        facet_grid(. ~ n)
}
```
         
         
# Power analysis
Generate pairs of correlated time-series (effect 0.1, 1, or 10) with error and correlate the slopes. Time-series have a fixed length (10) or a variety of lengths from (3 to 102 steps). Do this 100 times to check for true positive rate with a one-stage mixed-effects analysis.  
```{r, echo = FALSE}
if(!file.exists(here('temp', 'simulated_ts_temp_pow.csv.gz')) & !file.exists(here('output', 'simulated_ts_pow.csv.gz'))){
    stop('Need to run duration_sim_pow.R first.')
} else {
    #corspower <- fread(here('temp', 'simulated_ts_temp_pow.csv.gz'))
    corspower <- fread(here('output', 'simulated_ts_pow.csv.gz'))
    
    corspowerl <- melt(corspower, id.vars = c('n', 'minduration', 'maxduration', 'name', 'range', 'effect'), measure.vars = c('lm.p', 'lm.m', 'glmmwgt.p', 'glmmwgt.beta', 'glmmonebeta.p', 'glmmonebeta.beta'))
    
    proppower <- corspowerl[variable %in% c('lm.p', 'glmmwgt.p', 'glmmonebeta.p'), 
                  .(nsims = sum(!is.na(value)), propdetect = sum(value < 0.05, na.rm=TRUE)/sum(!is.na(value), na.rm=TRUE)), by = c("range", "n", "variable", "effect")]
    proppower[nsims >0, c("lower", "upper") := binomci(nsims*propdetect, nsims), by = .(range, n, variable, effect)]
    
    dg = position_dodge(0.1)
    ggplot(proppower, aes(effect, propdetect, group = variable, color = variable)) +
        geom_line(position = dg) +
        geom_point(position = dg) +
        geom_errorbar(aes(ymin=lower, ymax=upper), width=.1, position = dg) +
        labs(x = 'Effect size', title = 'Comparison of power', y = 'Proportion true positives') +
        lims(y = c(0,1)) +
        scale_x_log10() + 
        geom_abline(intercept = 0.8, slope = 0, linetype = 'dashed', color = 'red') +
        facet_grid(. ~ range, labeller = label_both)
}
```



