---
title: "Demonstration of the correlation generated by similar durations"
output: 
    github_document: default
---

```{r setup, echo = FALSE}
require(data.table)
require(ggplot2)
require(ggpubr) # for ggarrange
library(here)
```

# Plot an example
```{r}
set.seed(5)
dat <- data.table(tsid = rep(1:1000, rep(3:102, 1000/100)))
dat[, ':='(value1 = rnorm(.N), value2 = rnorm(.N))]
slopes <- dat[, .(slope1 = as.numeric(coef(lm(value1 ~ I(1:length(value1)))))[2], slope2 = as.numeric(coef(lm(value2 ~ I(1:length(value2)))))[2]), by = tsid]

slopes[, cor.test(slope1, slope2)]

slopes[, plot(slope1, slope2)]

```

# False positive analysis
Generate pairs of random time-series and correlate the slopes. Time-series have a random length 3 to 100 steps.
```{r}
if(file.exists(here('output', 'simulated_ts.csv.gz'))){
    cors <- fread(here('output', 'simulated_ts.csv.gz'))
} else {
    set.seed(5)
    nreps <- 100 # number of datasets
    
    cors <- data.table(n = 1000, minduration = rep(c(10,3,3,3,3), nreps), maxduration = rep(c(10, 12, 27, 52, 102), nreps), p = NA_real_, cor = NA_real_) # holds the summaries from each dataset. use n = 1000 timeseries per dataset.
    cors2 <- copy(cors)
    cors2[, n:=10000] # add another run with 10k timeseries per dataset
    cors <- rbind(cors, cors2) 
    rm(cors2)
    
    pb <- txtProgressBar(min = 0, max = nrow(cors), style = 3) # progress bar
    
    for(i in 1:nrow(cors)){
        # make datasets with timeseries of all the same length
        if(cors[i, minduration == maxduration]){
            len <- cors[i, minduration]
            dat <- data.table(tsid = rep(1:cors[i,n], rep(len, cors[i,n])), index = rep(1:len, cors[i,n]), value1 = rnorm(len*cors[i,n]), value2 = rnorm(len*cors[i,n]))
        }
        
        # variable length timeseries
        if(cors[i, minduration != maxduration]){
            mind <- cors[i, minduration]
            maxd <- cors[i, maxduration]
            ndur <- maxd - mind + 1
            dat <- data.table(tsid = rep(1:cors[i,n], rep(mind:maxd, cors[i,n]/ndur)))
            dat[, ':='(value1 = rnorm(.N), value2 = rnorm(.N))]
        }
        
        # calc slopes
        slopes <- dat[, .(slope1 = as.numeric(coef(lm(value1 ~ I(1:length(value1)))))[2], slope2 = as.numeric(coef(lm(value2 ~ I(1:length(value2)))))[2]), by = tsid]
        
        test <- slopes[, cor.test(slope1, slope2)]
        cors[i, ':='(p = test$p.value, cor = test$estimate)]    
        setTxtProgressBar(pb, i)
    }
    close(pb)
    
    cors[, name := paste0(minduration, '-', maxduration)]
    cors[, range := maxduration - minduration]
    
    write.csv(cors, gzfile(here('output', 'simulated_ts.csv.gz')), row.names = FALSE)
}
```




# Plot the results
```{r}
ylims = c(-10, 0)
p1 <- ggplot(cors, aes(range, log10(p), group = as.factor(n), color = as.factor(n))) +
           geom_point() +
           geom_smooth() +
           labs(x = 'Range of durations', title = 'Raw timeseries') +
           lims(y = ylims) +
           geom_abline(intercept = log10(0.05), slope = 0, linetype = 'dashed', color = 'red')

p2 <- ggplot(cors, aes(as.factor(range), log10(p), group = as.factor(n), color = as.factor(n))) +
           geom_violin() +
           labs(x = 'Range of durations', title = 'Raw timeseries') +
           lims(y = ylims) +
           geom_abline(intercept = log10(0.05), slope = 0, linetype = 'dashed', color = 'red')

p3 <- ggplot(cors[, .(prop = sum(p < 0.05)/length(p)), by = c("range", "n")], 
             aes(range, prop, group = as.factor(n), color = as.factor(n))) +
    geom_col(position = "dodge") +
    labs(x = 'Range of durations', title = 'Raw timeseries', y = 'Proportion false positive') +
    lims(y = c(0,1)) +
    geom_abline(intercept = 0.05, slope = 0, linetype = 'dashed', color = 'red')

ggarrange(p1, p2, p3, ncol = 2, nrow = 2)

```
         
         