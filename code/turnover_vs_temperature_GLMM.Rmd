---
title: 'Community dissimilarity through time using beta models: Evaluate and plot models'
output: 
    github_document: default

---
# Prep
First run turnover_vs_temperature_GLMM_fit.R to fit the models.
```{r setup, echo=FALSE}
library(data.table) # for handling large datasets
library(ggplot2) # for some plotting
library(glmmTMB) # for ME models
library(lme4) # for plotting random effects dotplot
library(bbmle) # for AICtab
library(gridExtra) # to combine ggplots together
library(grid) # to combine ggplots together
library(RColorBrewer)
library(scales) # for defining custom scales in ggplot
library(DHARMa) # for model diagnostics
library(here) # for relative paths
library(performance) # for r2 calculations

options(width=500) # turn off most text wrapping

signedsqrt = function(x) sign(x)*sqrt(abs(x))
signedsq = function(x) sign(x) * x^2
signedsqrttrans <- trans_new(name = 'signedsqrt', transform = signedsqrt, inverse = signedsq)


# tell RStudio to use project root directory as the root for this notebook. Needed since we are storing code in a separate directory.
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file()) 

# Turnover and covariates assembled by turnover_vs_temperature_prep.Rmd
trendsall <- fread(here('output', 'turnover_w_covariates.csv.gz'))
trends3 <- fread(here('output', 'turnover_w_covariates3.csv.gz'))
trends5 <- fread(here('output', 'turnover_w_covariates5.csv.gz'))
trends10 <- fread(here('output', 'turnover_w_covariates10.csv.gz'))
trends20 <- fread(here('output', 'turnover_w_covariates20.csv.gz'))

# And the scaling factors
scalingall <- fread(here('output', 'turnover_w_covariates_scaling.csv'))


```


# Summary stats
## Examine how many data points are available
### Just turnover and non-zero tempchange
```{r sample size all}
cat('Overall # dissimilarities: ', nrow(trendsall), '\n')
cat('# studies: ', trendsall[, length(unique(STUDY_ID))], '\n')
cat('# timeseries: ', trendsall[, length(unique(rarefyID))], '\n')
trendsall[!duplicated(rarefyID), table(REALM)]
trendsall[!duplicated(rarefyID), table(taxa_mod)]
trendsall[!duplicated(rarefyID), table(taxa_mod, REALM)]
```

### With all covariates
Use Bowler for human impact
```{r sample size Jtu covariates}
# the cases we can compare
apply(trendsall[, .(Jtu.sc, REALM, tempave_metab.sc, seas.sc, microclim.sc, tempchange.sc, mass.sc, speed.sc, consumerfrac.sc, endothermfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, veg.sc, human_bowler.sc)], MARGIN = 2, FUN = function(x) sum(!is.na(x)))
i <- trendsall[, complete.cases(Jtu.sc, tempave_metab.sc, seas.sc, microclim.sc, tempchange.sc, mass.sc, speed.sc, consumerfrac.sc, nspp.sc, thermal_bias.sc, npp.sc, veg.sc, human_bowler.sc)]
cat('Overall # dissimilarities: ', sum(i), '\n')
cat('# studies: ', trendsall[i, length(unique(STUDY_ID))], '\n')
cat('# timeseries: ', trendsall[i, length(unique(rarefyID))], '\n')
trendsall[i & !duplicated(rarefyID), table(REALM)]
trendsall[i & !duplicated(rarefyID), table(taxa_mod)]
trendsall[i & !duplicated(rarefyID), table(taxa_mod, REALM)]
```

# Models
## Choose the variance structure
Try combinations of

- beta errors
- variance scaled to Nspp or to Nspp + REALM
- random intercept for taxa_mod2, STUDY_ID, rarefyID
- random slopes for duration

Did not try random intercept for compID (for overdispersion), since had trouble converging.
Use a full set of fixed effects and choose the RE with lowest AIC.
Many of the 3- and 5-year models with random slopes had singular convergence issues.

### 10-years
This chooses beta errors, random slopes (duration.sc) & intercepts for STUDY_ID and rarefyID, and variance scaled to nspp + realm.
We haven't dealt with potential testing on the boundary issues here.
```{r choose variance structure, echo=FALSE}
mods10 <- vector('list', length = 17)
i = 1
if(file.exists(here('temp', 'modRFgauss10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFgauss10.rds')); names(mods10)[i] <- 'modRFgauss10'; i = i+1}
if(file.exists(here('temp', 'modRFbeta10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFbeta10.rds')); names(mods10)[i] <- 'modRFbeta10'; i = i+1}
if(file.exists(here('temp', 'modRFrID10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFrID10.rds')); names(mods10)[i] <- 'modRFrID10'; i = i+1}
if(file.exists(here('temp', 'modRF2lev10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRF2lev10.rds')); names(mods10)[i] <- 'modRF2lev10'; i = i+1}
if(file.exists(here('temp', 'modRFnestedRE10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFnestedRE10.rds')); names(mods10)[i] <- 'modRFnestedRE10'; i = i+1}
if(file.exists(here('temp', 'modRFslopeRE10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFslopeRE10.rds')); names(mods10)[i] <- 'modRFslopeRE10'; i = i+1}
if(file.exists(here('temp', 'modRFslopeRE2lev10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFslopeRE2lev10.rds')); names(mods10)[i] <- 'modRFslopeRE2lev10'; i = i+1}
if(file.exists(here('temp', 'modRFdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFdisp10.rds')); names(mods10)[i] <- 'modRFdisp10'; i = i+1}
if(file.exists(here('temp', 'modRF2levdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRF2levdisp10.rds')); names(mods10)[i] <- 'modRF2levdisp10'; i = i+1}
if(file.exists(here('temp', 'modRFslopeRE2levdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFslopeRE2levdisp10.rds')); names(mods10)[i] <- 'modRFslopeRE2levdisp10'; i = i+1}
if(file.exists(here('temp', 'modRFslopeREdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFslopeREdisp10.rds')); names(mods10)[i] <- 'modRFslopeREdisp10'; i = i+1}
if(file.exists(here('temp', 'modRF2levdisprealm10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRF2levdisprealm10.rds')); names(mods10)[i] <- 'modRF2levdisprealm10'; i = i+1}
if(file.exists(here('temp', 'modRFslopeRE2levdisprealm10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFslopeRE2levdisprealm10.rds')); names(mods10)[i] <- 'modRFslopeRE2levdisprealm10'; i = i+1}

# with log duration
if(file.exists(here('temp', 'modRFdurlog2levdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFdurlog2levdisp10.rds')); names(mods10)[i] <- 'modRFdurlog2levdisp10'; i = i+1}
if(file.exists(here('temp', 'modRFdurlogslopeRE2levdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFdurlogslopeRE2levdisp10.rds')); names(mods10)[i] <- 'modRFdurlogslopeRE2levdisp10'; i = i+1}
# if(file.exists(here('temp', 'modRFdurlogslopeREdisp10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFdurlogslopeREdisp10.rds')); names(mods10)[i] <- 'modRFdurlogslopeREdisp10'; i = i+1} # convergence error
if(file.exists(here('temp', 'modRFdurlog2levdisprealm10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFdurlog2levdisprealm10.rds')); names(mods10)[i] <- 'modRFdurlog2levdisprealm10'; i = i+1}
if(file.exists(here('temp', 'modRFdurlogslopeRE2levdisprealm10.rds'))){ mods10[[i]] <- readRDS(here('temp', 'modRFdurlogslopeRE2levdisprealm10.rds')); names(mods10)[i] <- 'modRFdurlogslopeRE2levdisprealm10'; i = i+1}

modes <- sapply(X = mods10, FUN = mode)
aics <- sapply(X = mods10[modes == 'list'], FUN = AIC)
aics - min(aics)
```


### Summary of the chosen model

```{r, echo=FALSE}
summary(mods10[[which(names(mods10)=='modRFslopeRE2levdisprealm10')]])
```


### Plot random effects
No clear discontinuities. Looks ok.
```{r, echo=FALSE}
lme4:::dotplot.ranef.mer(ranef(mods10[[which(names(mods10)=='modRFslopeRE2levdisprealm10')]])$cond)
```

### DHARMa model evaluation
```{r, echo=FALSE, eval=FALSE}
## run the top part by hand if needed. takes ~3 hrs
if(FALSE) {
  i10 <- trends10[, complete.cases(Jtu.sc, tempchange_abs.sc, REALM, tempave_metab.sc, duration.sc, mass.sc, 
                                   endothermfrac.sc, microclim.sc, npp.sc, human_bowler.sc, nspp.sc)]

  res_RFslopeRE2levdisprealm10 <- simulateResiduals(mods10[[which(names(mods10)=='modRFslopeRE2levdisprealm10')]], n = 250)
  
  saveRDS(res_RFslopeRE2levdisprealm10, file = 'temp/res_RFslopeRE2levdisprealm10.rds')
} else {
  if(file.exists('temp/res_RFslopeRE2levdisprealm10.rds')) res_RFslopeRE2levdisprealm10 <- readRDS('temp/res_res_RFslopeRE2levdisprealm10.rds')
  i10 <- trends10[, complete.cases(Jtu.sc, tempchange_abs.sc, REALM, tempave_metab.sc, duration.sc, mass.sc, 
                                   endothermfrac.sc, microclim.sc, npp.sc, human_bowler.sc, nspp.sc)]
}
```

#### Plot residuals for model fit to all data
There are many outliers and signs of underdispersion, but this is probably ok.
```{r, echo=FALSE, eval=FALSE}
if(exists('res_RFslopeRE2levdisprealm10')){
  plot(res_RFslopeRE2levdisprealm10)
  plotResiduals(res_RFslopeRE2levdisprealm10, form=trends10$tempchange_abs.sc[i10], xlab = 'tempchange_abs.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, form=trends10$REALM[i10], xlab = 'REALM', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, trends10$tempave_metab.sc[i10], xlab = 'tempave_metab.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, trends10$duration.sc[i10], xlab = 'duration.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, trends10$mass.sc[i10], xlab = 'mass.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, trends10$endothermfrac.sc[i10], xlab = 'endothermfrac.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, trends10$microclim.sc[i10], xlab = 'microclim.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, trends10$npp.sc[i10], xlab = 'npp.sc', main = '')
  plotResiduals(res_RFslopeRE2levdisprealm10, form=trends10$human_bowler.sc[i10], xlab = 'human_bowler.sc', main = '')
}
```


#### Overdispersion
There is underdispersion.
```{r, echo=FALSE, eval=FALSE}
testDispersion(res_RFslopeRE2levdisprealm10)

```

#### Near-zero-inflation
(Zero values have been transformed to slightly >0, so can't test zero-inflation directly)

Near-zero values are not inflated.
```{r, eval=FALSE}
countNearZero <- function(x) sum(x < 0.0001)
testGeneric(res_RFslopeRE2levdisprealm10, summary = countNearZero, alternative = 'greater')

```

#### Near-one-inflation
Near-one values are not inflated.
```{r, eval=FALSE}
countNearOne <- function(x) sum(x > 0.9999)
testGeneric(res_RFslopeRE2levdisprealm10, summary = countNearOne, alternative = 'greater')

```


## Temperature, temperature slope & duration models
### Load the models
```{r temperature, temp slope and duration, eval=FALSE, echo=FALSE}
# all years
modTdT10 <- readRDS('temp/modTdT10.rds')
```

### Summary
```{r summary of TD mods, eval=FALSE, echo=FALSE}
summary(modTdT10)
```



### Plot the coefficients
Not used
```{r modTD coefs, eval=FALSE, echo=FALSE}

coefs1 <- summary(modTDJtu)$coefficients$cond
coefs2 <- summary(modTDJbeta)$coefficients$cond
coefs3 <- summary(modTDHorn)$coefficients$cond

varstoplot <- unique(c(rownames(coefs1), rownames(coefs2), rownames(coefs3)))
varstoplot <- varstoplot[which(!grepl('Intercept', varstoplot) | grepl(':', varstoplot))] # vars to plot

rows1_1 <- which(rownames(coefs1) %in% varstoplot) # rows in coefs
rows1_2 <- which(rownames(coefs2) %in% varstoplot)
rows1_3 <- which(rownames(coefs3) %in% varstoplot)
xlims <- range(c(coefs1[rows1_1,1] - 1.96*coefs1[rows1_1,2], coefs1[rows1_1,1] + 1.96*coefs1[rows1_1,2], 
                  coefs2[rows1_2,1] - 1.96*coefs2[rows1_2,2], coefs2[rows1_2,1] + 1.96*coefs2[rows1_2,2], 
                  coefs3[rows1_3,1] - 1.96*coefs3[rows1_3,2], coefs3[rows1_3,1] + 1.96*coefs3[rows1_3,2]))

cols <- brewer.pal(3, 'Dark2') # for Jtu, Jbeta and Horn models
pchs <- c(16, 16, 16)
offs <- c(0.1, 0, -0.1) # offset vertically for each model

par(las = 1, mai = c(0.5, 4, 0.1, 0.1))

plot(0,0, col = 'white', xlim = xlims, ylim = c(0.9,length(varstoplot)+0.1), yaxt='n', xlab = '', ylab ='')
axis(2, at = length(varstoplot):1, labels = varstoplot, cex.axis = 0.7)
abline(v = 0, col = 'grey', lty = 2)
abline(h = 1:length(varstoplot), col = 'grey', lty = 3)
for(i in 1:length(varstoplot)){
  if(varstoplot[i] %in% rownames(coefs1)){
    x = coefs1[rownames(coefs1) == varstoplot[i], 1] # the coef in col 1
    se = coefs1[rownames(coefs1) == varstoplot[i], 2] # the SE in col 2
    points(x, length(varstoplot) + 1 - i + offs[1], pch = pchs[1], col = cols[1])
    lines(x = c(x-1.96*se, x+1.96*se), y = c(length(varstoplot) + 1 - i + offs[1], length(varstoplot) + 1 - i + offs[1]), col = cols[1])
  }
  if(varstoplot[i] %in% rownames(coefs2)){
    x = coefs2[rownames(coefs2) == varstoplot[i], 1]
    se = coefs2[rownames(coefs2) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[2], pch = pchs[2], col = cols[2])
    lines(x = c(x-1.96*se, x+1.96*se), y = c(length(varstoplot) + 1 - i + offs[2], length(varstoplot) + 1 - i + offs[2]), col = cols[2])
  }
  if(varstoplot[i] %in% rownames(coefs3)){
    x = coefs3[rownames(coefs3) == varstoplot[i], 1]
    se = coefs3[rownames(coefs3) == varstoplot[i], 2]
    points(x, length(varstoplot) + 1 - i + offs[3], pch = pchs[3], col = cols[3])
    lines(x = c(x-1.96*se, x+1.96*se), y = c(length(varstoplot) + 1 - i + offs[3], length(varstoplot) + 1 - i + offs[3]), col = cols[3])
  }
}
legend('bottomright', col = cols, pch = 16, lwd = 1, legend = c('Jtu', 'Jbeta', 'Horn'), cex = 0.5)
```
abs(tempchange) is in degC

duration is in years

### Plot the response
Not used
```{r plot TD response, eval=FALSE, echo=FALSE}
if(!file.exists('temp/modTDJtu_preds.rds')) {
  newdat <- expand.grid(duration = c(1, 50), tempchange = seq(0.01, 5, length.out = 5), 
                      taxa_mod2 = NA, STUDY_ID = NA, rarefyID = NA,
                      Nspp = 60) # no REs, ave number of species
  scaling <- fread('output/turnover_w_covariates_scaling.csv')
  cent <- scaling$center[scaling$var == 'tempchange_abs.sc'] # centering
  scl <- scaling$scale[scaling$var == 'tempchange_abs.sc'] # scaling factor for tempchange
  newdat$tempchange_abs.sc <- (abs(newdat$tempchange)-cent)/scl
  cent <- scaling$center[scaling$var == 'nspp.sc'] # centering
  scl <- scaling$scale[scaling$var == 'nspp.sc'] # scaling factor for tempchange
  newdat$nspp.sc <- (log(newdat$Nspp) - cent)/scl
  Jtu <- predict(modTDJtu, newdata = newdat, se.fit = TRUE, re.form = NA, type = 'response')
  newdat$durationfac <- as.factor(newdat$duration)
  newdat$Jtu <- Jtu$fit
  newdat$Jtu.se <- Jtu$se.fit
  
  saveRDS(newdat, file = 'temp/modTDJtu_preds.rds')
} else {
  newdat <- readRDS('temp/modTDJtu_preds.rds')
}

ggplot(newdat, aes(tempchange, Jtu, color = durationfac, group = durationfac)) +
  geom_line() +
  geom_ribbon(aes(ymin=Jtu - 1.96*Jtu.se, ymax=Jtu + 1.96*Jtu.se), alpha = 0.1, linetype = 'blank')
```

## Temperature*temperature slope & duration models
### Load the models
```{r temperature by temp slope and duration, eval=FALSE, echo=FALSE}
modTdTT10 <- readRDS('temp/modTdTT10.rds')
modTdTT10Horn <- readRDS('temp/modTdTT10Horn.rds')
```

### Plot the response
#### Set up and write to file
Only run this once.
```{r, eval=FALSE, echo=FALSE}
scaling10 <- fread('output/turnover_w_covariates_scaling10.csv') # the scalings

# find a study in all 3 datasets to use as the random effect
# ranef(modTdT20Horn))

# set up the variables to plot
vars <- data.frame(vars = c('tempchange_abs', 'tempave_metab'),
                   min =      c(0,    -10), 
                   max =      c(0.7,    40),
                   len =      c(100,  100),
                   discrete = c(F,    F),
                   stringsAsFactors = FALSE)
basetab10 <- data.table(expand.grid(start = 1:9, end = 2:10, nspp.sc = 0, REALM = 'Terrestrial', STUDY_ID = 195L, rarefyID = '195_289043', tempchange_abs.sc = 0, tempave_metab.sc = 0)) # the base case
basetab10[, duration := end - start]
if(scaling10[var == 'duration.sc', log]) basetab10[, duration.sc := (log(duration) - scaling10[var == 'duration.sc', center])/scaling10[var == 'duration.sc', scale]]
if(!scaling10[var == 'duration.sc', log]) basetab10[, duration.sc := (duration - scaling10[var == 'duration.sc', center])/scaling10[var == 'duration.sc', scale]]
basetab10 <- basetab10[duration > 0, ]

# make the data frames for each interaction to plot                
for(j in 1:nrow(vars)){
    # set up the main effects
    if(scaling5[var == paste0(vars$vars[j], '.sc'), log]){
        thisdat <- data.frame(new = 10^seq(log10(vars$min[j]), log10(vars$max[j]), length.out = vars$len[j]),
                              var = vars$vars[j], stringsAsFactors = FALSE)
    } 
    if(!scaling5[var == paste0(vars$vars[j], '.sc'), log]){
        thisdat <- data.frame(new = seq(vars$min[j], vars$max[j], length.out = vars$len[j]),
                              var = vars$vars[j], stringsAsFactors = FALSE)
    }
    names(thisdat) <- c(vars$vars[j], 'var')
    
    # scale the variable
    cent <- scaling5[var == paste0(vars$vars[j], '.sc'), center]
    scl <- scaling5[var == paste0(vars$vars[j], '.sc'), scale]
    lg <- scaling5[var == paste0(vars$vars[j], '.sc'), log]
    plus <- scaling5[var == paste0(vars$vars[j], '.sc'), plus]
    if(is.null(cent)) cent <- 0
    if(!is.null(cent) & !is.null(scl)){
        if(lg) thisdat[[paste0(vars$var[j], '.sc')]] <- (log(thisdat[[vars$vars[j]]] + plus) - cent)/scl
        if(!lg) thisdat[[paste0(vars$var[j], '.sc')]] <- (thisdat[[vars$var[j]]] - cent)/scl
    }
    
    # merge with the rest of the columns
    expand.grid.df <- function(...) Reduce(function(...) merge(..., by=NULL), list(...)) # https://stackoverflow.com/questions/11693599/alternative-to-expand-grid-for-data-frames
    colnamestouse <- setdiff(colnames(basetab5), paste0(vars$vars[j], '.sc'))
    thisdat10 <- expand.grid.df(thisdat, basetab10[, ..colnamestouse])

    # merge with the previous iterations
    if(j == 1){
      newdat10 <- thisdat10
    }
    if(j > 1){
        colstoadd <- setdiff(colnames(thisdat5), colnames(newdat5))
        for(toadd in colstoadd){
            newdat10[[toadd]] <- NA
        }
        
        colstoadd2 <- setdiff(colnames(newdat5), colnames(thisdat5))
        for(toadd in colstoadd2){
            thisdat10[[toadd]] <- NA
        }
        
        newdat10 <- rbind(newdat10, thisdat10)
    } 
}

# predict (takes a few minutes on Annotate)
logit <- function(p) return(log(p/(1-p)))
invlogit <- function(x) return(1/(1+exp(-x)))

coefs10 <- (summary(modTdTT10Horn)$coefficients)

newdat10$Horn.sc <- predict(modTdTT10Horn, newdat = newdat10, type = 'response', se.fit = FALSE, re.form = NA)


newdat10$Horn.sc.dTu <- invlogit(logit(newdat10$Horn.sc) + 
                                  newdat10$tempchange_abs.sc * newdat10$duration.sc *
                                  coefs10$cond[3,2]) # upper bound on tempchange coef
newdat10$Horn.sc.dTl <- invlogit(logit(newdat10$Horn.sc) - 
                                  newdat10$tempchange_abs.sc * newdat10$duration.sc *
                                  coefs10$cond[3,2]) # lower bound on tempchange coef
newdat10$Horn.sc.Tu <- invlogit(logit(newdat10$Horn.sc) + 
                                 newdat10$tempave_metab.sc * newdat10$duration.sc *
                                 coefs10$cond[4,2]) # upper bound on tempchange coef
newdat10$Horn.sc.Tl <- invlogit(logit(newdat10$Horn.sc) - 
                                 newdat10$tempave_metab.sc * newdat10$duration.sc *
                                 coefs10$cond[4,2]) # lower bound on tempchange coef


# write out
write.csv(newdat10, 'temp/modTdTT10_preds.csv', row.names = FALSE)

```

#### Plot
```{r}
# load predictions
newdat10 <- fread('temp/modTdTT10_preds.csv')

# calc duration slope per temp:tempchange level
slope <- function(duration, Horn.sc){
  mod <- lm(Horn.sc ~ duration)
  return(coef(mod)[2])
}
slope10 <- newdat10[, .(Hornslope = slope(duration, Horn.sc), 
                      HornslopedTu = slope(duration, Horn.sc.dTu),
                      HornslopedTl = slope(duration, Horn.sc.dTl), 
                      HornslopeTu = slope(duration, Horn.sc.Tu),
                      HornslopeTl = slope(duration, Horn.sc.Tl)), 
                  by = .(tempchange_abs, tempave_metab)]

p1 <- ggplot(slope10, aes(x=tempchange_abs, y=Hornslope, ymin=HornslopedTu, ymax=HornslopedTl)) +
  geom_line() + 
  geom_ribbon(alpha=0.2)
  
p2 <- ggplot(slope10, aes(x=tempave_metab, y=Hornslope, ymin=HornslopeTu, ymax=HornslopeTl)) +
  geom_line() +
  geom_ribbon(alpha=0.2)

grid.arrange(p1, p2, ncol = 2)
```

## Temperature+temperature slope+REALM : duration models
### Load the models
```{r, eval=FALSE, echo=FALSE}
modTdTRealm5Jtu <- readRDS('temp/modTdTRealm5Jtu.rds')
modTdTRealm5Horn <- readRDS('temp/modTdTRealm5Horn.rds')
```

### Plot the response
#### Set up and write to file
Only run this once.
```{r, eval=FALSE, echo=FALSE}
scaling5 <- fread('output/turnover_w_covariates_scaling5.csv') # the scalings

# find a study in all 3 datasets to use as the random effect
# ranef(modTdTTRealm5Horn))

# set up the variables to plot
vars <- data.frame(vars = c('tempchange_abs', 'tempave_metab'),
                   min =      c(0,    -10), 
                   max =      c(0.7,    40),
                   len =      c(100,  100),
                   discrete = c(F,    F),
                   stringsAsFactors = FALSE)
basetab5 <- data.table(expand.grid(start = 1:4, end = 2:5, nspp.sc = 0, REALM = c('Terrestrial', 'Freshwater', 'Marine'), STUDY_ID = 195L, rarefyID = '195_289043', tempchange_abs.sc = 0, tempave_metab.sc = 0)) # the base case
basetab5[, duration := end - start]
if(scaling5[var == 'duration.sc', log]) basetab5[, duration.sc := (log(duration) - scaling5[var == 'duration.sc', center])/scaling5[var == 'duration.sc', scale]]
if(!scaling5[var == 'duration.sc', log]) basetab5[, duration.sc := (duration - scaling5[var == 'duration.sc', center])/scaling5[var == 'duration.sc', scale]]
basetab5 <- basetab5[duration > 0, ]

# make the data frames for each interaction to plot                
for(j in 1:nrow(vars)){
    # set up the main effects
    if(scaling5[var == paste0(vars$vars[j], '.sc'), log]){
        thisdat <- data.frame(new = 10^seq(log10(vars$min[j]), log10(vars$max[j]), length.out = vars$len[j]),
                              var = vars$vars[j], stringsAsFactors = FALSE)
    } 
    if(!scaling5[var == paste0(vars$vars[j], '.sc'), log]){
        thisdat <- data.frame(new = seq(vars$min[j], vars$max[j], length.out = vars$len[j]),
                              var = vars$vars[j], stringsAsFactors = FALSE)
    }
    names(thisdat) <- c(vars$vars[j], 'var')
    
    # scale the variable
    cent <- scaling5[var == paste0(vars$vars[j], '.sc'), center]
    scl <- scaling5[var == paste0(vars$vars[j], '.sc'), scale]
    lg <- scaling5[var == paste0(vars$vars[j], '.sc'), log]
    plus <- scaling5[var == paste0(vars$vars[j], '.sc'), plus]
    if(is.null(cent)) cent <- 0
    if(!is.null(cent) & !is.null(scl)){
        if(lg) thisdat[[paste0(vars$var[j], '.sc')]] <- (log(thisdat[[vars$vars[j]]] + plus) - cent)/scl
        if(!lg) thisdat[[paste0(vars$var[j], '.sc')]] <- (thisdat[[vars$var[j]]] - cent)/scl
    }
    
    # merge with the rest of the columns
    expand.grid.df <- function(...) Reduce(function(...) merge(..., by=NULL), list(...)) # https://stackoverflow.com/questions/11693599/alternative-to-expand-grid-for-data-frames
    colnamestouse <- setdiff(colnames(basetab5), paste0(vars$vars[j], '.sc'))
    thisdat5 <- expand.grid.df(thisdat, basetab5[, ..colnamestouse])
    
    # merge with the previous iterations
    if(j == 1){
      newdat5 <- thisdat5
    }
    if(j > 1){
        colstoadd <- setdiff(colnames(thisdat5), colnames(newdat5))
        for(toadd in colstoadd){
            newdat5[[toadd]] <- NA
        }
        
        colstoadd2 <- setdiff(colnames(newdat5), colnames(thisdat5))
        for(toadd in colstoadd2){
            thisdat5[[toadd]] <- NA
        }
        
        newdat5 <- rbind(newdat5, thisdat5)
    } 
}
newdat5 <- as.data.table(newdat5)

# predict (takes a few minutes on Annotate)
logit <- function(p) return(log(p/(1-p)))
invlogit <- function(x) return(1/(1+exp(-x)))

coefs5Jtu <- summary(modTdTRealm5Jtu)$coefficients$cond # get the model coefficients and SE
terms5Jtu <- rownames(coefs5Jtu)

newdat5[, Jtu.sc := predict(modTdTRealm5Jtu, newdat = newdat5, type = 'response', 
                            se.fit = FALSE, re.form = NA)] # make the predictions

newdat5[, Jtu.sc.dTu := invlogit(logit(Jtu.sc) + 
                                      tempchange_abs.sc * duration.sc *
                                      coefs5Jtu[terms5Jtu == 
                                                  'duration.sc:tempchange_abs.sc',2])] # upper bound on dT coef
newdat5[, Jtu.sc.dTl := invlogit(logit(Jtu.sc) - 
                                  tempchange_abs.sc * duration.sc *
                                  coefs5Jtu[terms5Jtu == 'duration.sc:tempchange_abs.sc',2])] # lower bound

newdat5[, Jtu.sc.Tu := invlogit(logit(Jtu.sc) + 
                                 tempave_metab.sc * duration.sc *
                                 coefs5Jtu[terms5Jtu == 'duration.sc:tempave_metab.sc',2])] # upper bound on T coef
newdat5[, Jtu.sc.Tl := invlogit(logit(Jtu.sc) - 
                                 tempave_metab.sc * duration.sc *
                                 coefs5Jtu[terms5Jtu == 'duration.sc:tempave_metab.sc',2])]

## Horn
coefs5Horn <- summary(modTdTRealm5Horn)$coefficients$cond # get the model coefficients and SE
terms5Horn <- rownames(coefs5Horn)

newdat5[, Horn.sc := predict(modTdTRealm5Horn, newdat = newdat5, type = 'response', 
                             se.fit = FALSE, re.form = NA)] # make the predictions

newdat5[, Horn.sc.dTu := invlogit(logit(Horn.sc) + 
                                      tempchange_abs.sc * duration.sc *
                                      coefs5Horn[terms5Horn == 
                                                  'duration.sc:tempchange_abs.sc',2])] # upper bound on dT coef
newdat5[, Horn.sc.dTl := invlogit(logit(Horn.sc) - 
                                  tempchange_abs.sc * duration.sc *
                                  coefs5Horn[terms5Horn == 'duration.sc:tempchange_abs.sc',2])] # lower bound

newdat5[, Horn.sc.Tu := invlogit(logit(Horn.sc) + 
                                 tempave_metab.sc * duration.sc *
                                 coefs5Horn[terms5Horn == 'duration.sc:tempave_metab.sc',2])] # upper bound on T coef
newdat5[, Horn.sc.Tl := invlogit(logit(Horn.sc) - 
                                 tempave_metab.sc * duration.sc *
                                 coefs5Horn[terms5Horn == 'duration.sc:tempave_metab.sc',2])]


# write out
write.csv(newdat5, 'temp/modTdTRealm5_preds.csv', row.names = FALSE)

```

#### Plot
```{r}
# load predictions
newdat5 <- fread('temp/modTdTRealm5_preds.csv')

# calc duration slope per temp:tempchange level
slope <- function(duration, diss){
  mod <- lm(diss ~ duration)
  return(coef(mod)[2])
}
slope5 <- newdat5[, .(Jtuslope = slope(duration, Jtu.sc), 
                      JtuslopedTu = slope(duration, Jtu.sc.dTu),
                      JtuslopedTl = slope(duration, Jtu.sc.dTl), 
                      JtuslopeTu = slope(duration, Jtu.sc.Tu),
                      JtuslopeTl = slope(duration, Jtu.sc.Tl),
                      Hornslope = slope(duration, Horn.sc), 
                      HornslopedTu = slope(duration, Horn.sc.dTu),
                      HornslopedTl = slope(duration, Horn.sc.dTl), 
                      HornslopeTu = slope(duration, Horn.sc.Tu),
                      HornslopeTl = slope(duration, Horn.sc.Tl)), 
                  by = .(tempchange_abs, tempave_metab)]

p1 <- ggplot(slope5, aes(x=tempchange_abs, y=Jtuslope, ymin=JtuslopedTu, ymax=JtuslopedTl)) +
  geom_line() + 
  geom_ribbon(alpha=0.2)
  
p2 <- ggplot(slope5, aes(x=tempave_metab, y=Jtuslope, ymin=JtuslopeTu, ymax=JtuslopeTl)) +
  geom_line() +
  geom_ribbon(alpha=0.2)

p3 <- ggplot(slope5, aes(x=tempchange_abs, y=Hornslope, ymin=HornslopedTu, ymax=HornslopedTl)) +
  geom_line() + 
  geom_ribbon(alpha=0.2)
  
p4 <- ggplot(slope5, aes(x=tempave_metab, y=Hornslope, ymin=HornslopeTu, ymax=HornslopeTl)) +
  geom_line() +
  geom_ribbon(alpha=0.2)

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

## Temperature*temperature slope*REALM*duration (Antao-style)
```{r}
modTdTTRealmAllJtu <- readRDS('temp/modTdTTRealmAllJtu.rds') # uses duration and tempchange
#modTdTTRealmDurscAllJtu <- readRDS('temp/modTdTTRealmDurscAllJtu.rds') # uses duration.sc and tempchange
modTsdTTRealmAllJtu <- readRDS('temp/modTsdTTRealmAllJtu.rds') # uses duration and abs(tempchange)
modTsdTTRealmDurscAllJtu <- readRDS('temp/modTsdTTRealmDurscAllJtu.rds') # uses duration.sc and abs(tempchange)
```

### AIC
```{r}
AIC(modTsdTTRealmAllJtu, modTsdTTRealmDurscAllJtu) - min(AIC(modTsdTTRealmAllJtu, modTsdTTRealmDurscAllJtu)$AIC)
```

### Print terms
```{r, echo=FALSE}
summary(modTsdTTRealmAllJtu)
```

### Plot the interaction
```{r, echo = FALSE}
# set up prediction frame
newdatM <- data.table(expand.grid(tempave_metab.sc = seq(-1.6, 1.5, length.out = 100), tempchange_abs.sc = seq(-0.8, 20, length.out = 100), duration.sc = seq(-2, 2, length.out=10)))
newdatM$REALM <- 'Marine'
newdatM$STUDY_ID <- 1
newdatM$rarefyID <- 1
newdatM[, tempave_metab := tempave_metab.sc * scalingall[var == 'tempave_metab.sc', scale] + scalingall[var == 'tempave_metab.sc', center]]
newdatM[, tempchange_abs := tempchange_abs.sc * scalingall[var == 'tempchange_abs.sc', scale] + scalingall[var == 'tempchange_abs.sc', center]]

newdatT <- data.table(expand.grid(tempave_metab.sc = seq(-1.6, 1.5, length.out = 100), tempchange_abs.sc = seq(-0.8, 20, length.out = 100), duration.sc = seq(-2, 2, length.out=10)))
newdatT$REALM <- 'Terrestrial'
newdatT$STUDY_ID <- 1
newdatT$rarefyID <- 1
newdatT[, tempave_metab := tempave_metab.sc * scalingall[var == 'tempave_metab.sc', scale] + scalingall[var == 'tempave_metab.sc', center]]
newdatT[, tempchange_abs := tempchange_abs.sc * scalingall[var == 'tempchange_abs.sc', scale] + scalingall[var == 'tempchange_abs.sc', center]]

newdatF <- data.table(expand.grid(tempave_metab.sc = seq(-1.6, 1.5, length.out = 100), tempchange_abs.sc = seq(-0.8, 20, length.out = 100), duration.sc = seq(-2, 2, length.out=10)))
newdatF$REALM <- 'Freshwater'
newdatF$STUDY_ID <- 1
newdatF$rarefyID <- 1
newdatF[, tempave_metab := tempave_metab.sc * scalingall[var == 'tempave_metab.sc', scale] + scalingall[var == 'tempave_metab.sc', center]]
newdatF[, tempchange_abs := tempchange_abs.sc * scalingall[var == 'tempchange_abs.sc', scale] + scalingall[var == 'tempchange_abs.sc', center]]


# predict
newdatM$Jtu.sc <- predict(modTsdTTRealmDurscAllJtu, newdata = newdatM, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')
newdatT$Jtu.sc <- predict(modTsdTTRealmDurscAllJtu, newdata = newdatT, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')
newdatF$Jtu.sc <- predict(modTsdTTRealmDurscAllJtu, newdata = newdatF, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')

# calculate slopes
slopesM <- newdatM[, .(slope = coef(lm(Jtu.sc ~ duration.sc))[2]), by = .(tempave_metab, tempchange_abs)]
slopesT <- newdatT[, .(slope = coef(lm(Jtu.sc ~ duration.sc))[2]), by = .(tempave_metab, tempchange_abs)]
slopesF <- newdatF[, .(slope = coef(lm(Jtu.sc ~ duration.sc))[2]), by = .(tempave_metab, tempchange_abs)]

# plot
p1 <- ggplot(slopesM, aes(tempchange_abs, tempave_metab, z = slope)) +
    geom_raster(aes(fill = slope)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'Marine') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)
p2 <- ggplot(slopesT, aes(tempchange_abs, tempave_metab, z = slope)) +
    geom_raster(aes(fill = slope)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'Terrestrial') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)
p3 <- ggplot(slopesF, aes(tempchange_abs, tempave_metab, z = slope)) +
    geom_raster(aes(fill = slope)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'Freshwater') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)

p1
p2
p3
```



## Environment*Temperature*temperature slope*REALM*duration (Antao+)
```{r}
modTsdTTRealmnppAllJtu <- readRDS('temp/modTsdTTRealmnppAllJtu.rds') # has npp
modTsdTTRealmmicroclimAllJtu <- readRDS('temp/modTsdTTRealmmicroclimAllJtu.rds') # has microclimates

summary(modTsdTTRealmnppAllJtu)
summary(modTsdTTRealmmicroclimAllJtu)
```



### Plot the interaction for high and low environment values
Only for marine since no significant effect in other realms.
```{r, echo = FALSE}
# set up prediction frame
newdat1 <- data.table(expand.grid(tempave_metab.sc = seq(-1.6, 1.5, length.out = 100), tempchange_abs.sc = seq(-0.8, 20, length.out = 100), duration = 1:10))
newdat1$npp.sc <- -2 # low value (2 SD below the mean)
newdat1$microclim.sc <- -2
newdat1$REALM <- 'Marine'
newdat1$STUDY_ID <- 1
newdat1$rarefyID <- 1
newdat1[, tempave_metab := tempave_metab.sc * scalingall[var == 'tempave_metab.sc', scale] + scalingall[var == 'tempave_metab.sc', center]]
newdat1[, tempchange_abs := tempchange_abs.sc * scalingall[var == 'tempchange_abs.sc', scale] + scalingall[var == 'tempchange_abs.sc', center]]

newdat2 <- data.table(expand.grid(tempave_metab.sc = seq(-1.6, 1.5, length.out = 100), tempchange_abs.sc = seq(-0.8, 20, length.out = 100), duration = 1:10))
newdat2$npp.sc <- 2 # high value (2 SD above the mean)
newdat2$microclim.sc <- 2
newdat2$REALM <- 'Marine'
newdat2$STUDY_ID <- 1
newdat2$rarefyID <- 1
newdat2[, tempave_metab := tempave_metab.sc * scalingall[var == 'tempave_metab.sc', scale] + scalingall[var == 'tempave_metab.sc', center]]
newdat2[, tempchange_abs := tempchange_abs.sc * scalingall[var == 'tempchange_abs.sc', scale] + scalingall[var == 'tempchange_abs.sc', center]]

# predict
newdat1$Jtu.sc.npp <- predict(modTsdTTRealmnppAllJtu, newdata = newdat1, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')
newdat2$Jtu.sc.npp <- predict(modTsdTTRealmnppAllJtu, newdata = newdat2, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')
newdat1$Jtu.sc.microclim <- predict(modTsdTTRealmmicroclimAllJtu, newdata = newdat1, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')
newdat2$Jtu.sc.microclim <- predict(modTsdTTRealmmicroclimAllJtu, newdata = newdat2, se.fit = FALSE, re.form = NA, allow.new.levels=TRUE, type = 'response')

# calculate slopes
slopes1 <- newdat1[, .(slope_npp = coef(lm(Jtu.sc.npp ~ duration))[2],
                       slope_microclim = coef(lm(Jtu.sc.microclim ~ duration))[2]), by = .(tempave_metab, tempchange_abs)]
slopes2 <- newdat2[, .(slope_npp = coef(lm(Jtu.sc.npp ~ duration))[2],
                       slope_microclim = coef(lm(Jtu.sc.microclim ~ duration))[2]), by = .(tempave_metab, tempchange_abs)]

# plot
p1 <- ggplot(slopes1, aes(tempchange_abs, tempave_metab, z = slope_npp)) +
    geom_raster(aes(fill = slope_npp)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'Low NPP') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)
p2 <- ggplot(slopes2, aes(tempchange_abs, tempave_metab, z = slope_npp)) +
    geom_raster(aes(fill = slope_npp)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'High NPP') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)
p3 <- ggplot(slopes1, aes(tempchange_abs, tempave_metab, z = slope_microclim)) +
    geom_raster(aes(fill = slope_microclim)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'Low microclimate') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)
p4 <- ggplot(slopes2, aes(tempchange_abs, tempave_metab, z = slope_microclim)) +
    geom_raster(aes(fill = slope_microclim)) +
    labs(x = 'Temperature change (degC per year)', y = 'Long-term metabolic temperature (degC)', title = 'High microclimate') +
    scale_fill_gradient2(high= "#B2182B", mid = "white", low= "#2166AC", midpoint = 0) +
    theme(axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14),
          panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          legend.position = "top",
          legend.margin = margin(c(0, 0.1, -20, 0)),
          legend.justification = c(0.92, 0.9),
          legend.text=element_text(size= 12),
          legend.title=element_text(size= 18),
          legend.title.align = 1)

p1
p2
p3
p4
```



